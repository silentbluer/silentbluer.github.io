<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JavaScript的数据类型浅析</title>
    <link href="/2022/06/16/JavaScript%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%B5%85%E6%9E%90/"/>
    <url>/2022/06/16/JavaScript%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%B5%85%E6%9E%90/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
      <category>学习笔记</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>数据类型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript中相等和严格相等运算符的简要比较</title>
    <link href="/2022/06/12/Javascript%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%B8%A5%E6%A0%BC%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/"/>
    <url>/2022/06/12/Javascript%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%B8%A5%E6%A0%BC%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1-全等运算符">1. 全等运算符 ===</h2><p>首先，全等操作符比较两个值是否相等，两个被比较的值在比较前都不进行隐式转换。如果两个被比较的值具有不同的类型，这两个值是不全等的；其次，如果两个被比较的值类型相同，值也相同，并且都不是 number 类型时，两个值全等；最后，如果两个值都是 number 类型，当两个都不是 NaN，并且数值相同，或是两个值分别为 +0 和 -0 时，两个值被认为是全等的。</p><blockquote><p>注意，在全等运算中，NaN 与其他任何值相比,结果都是 false。</p></blockquote><h3 id="1-1-基本规则">1.1 基本规则</h3><div class="note note-info">            <p><strong>全等和不全等操作符遵循以下基本规则：</strong></p><ol><li>如果两个操作数有不同的类型，它们不是严格相等的；<br><code>1 === &quot;1&quot; // false, undefined === null // false</code></li><li>如果两个操作数都为 null，则它们是严格相等的；<br><code>null === null // true</code></li><li>如果两个操作数都为 undefined，它们是严格相等的；<br><code>undefined === undefined // true</code></li><li>如果一个或两个操作数都是 NaN，它们就不是严格相等的；<br><code>NaN === NaN // false</code></li><li>如果两个操作数都为 true 或都为 false，它们是严格相等的；<br><code>true === true //true, false === false; //true</code></li><li>如果两个操作数都是 number 类型并且具有相同的值，则它们是严格相等的；<br><code>0 === 0 // true</code></li><li>如果两个操作数都是 string 类型并且具有相同的值，则它们是严格相等的；<br><code>&quot;a&quot; === &quot;a&quot; //true</code></li><li>如果两个操作数都引用相同的对象或函数，则它们是严格相等的；<br><code>var firstObject = {},  secondObject = firstObject;</code><br><code>secondObject['name'] = 'Neo';</code><br><code>secondObject === firstObject // true</code></li><li>以上所有其他情况下操作数都不是严格相等的。<br><code>[] === [] //false</code><br><code>[]可以理解为new Array()，相当于声明了一个新的空数组，程序会自动在堆中为其开辟一块内存空间，[]和[]生成的内存空间不是同一块，所以自然不相等。</code></li></ol>          </div><h2 id="2-对象与原始值的转换">2. 对象与原始值的转换</h2><div class="note note-warning">            <p>待补充</p>          </div><h2 id="3-相等运算符">3. 相等运算符 ==</h2><p>如果两个操作数不是同一类型，那么相等运算符会尝试一些类型转换，然后进行比较。</p><h3 id="3-1-基本规则">3.1 基本规则</h3><div class="note note-info">            <blockquote><p>如果操作数具有相同的类型，请测试它们是否严格相等。 如果它们不严格相等，则它们不相等，否则相等。</p></blockquote><p><strong>如果操作数有不同的类型：</strong></p><ol><li>如果一个操作数为 null 而另一个 undefined，则它们相等;</li><li>如果一个值是数字，另一个是字符串，先将字符串转换为数字，然后使用转换后的值比较;</li><li>如果一个操作数是布尔值，则将 true 转换为 1，将 false 转换为 0，然后使用转换后的值比较;</li><li>如果一个操作数是一个对象，而另一个操作数是一个数字或字符串，则将该对象转换为原始值，再使用转换后的值比较;</li></ol><blockquote><p>在以上的其他情况下，操作数都不相等;</p></blockquote>          </div><h2 id="4-函数和方法">4. 函数和方法</h2><h3 id="4-1-switch…case">4.1 switch…case</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">switch</span> (expression) &#123;<br>   <span class="hljs-keyword">case</span> <span class="hljs-attr">value1</span>:<br>    <span class="hljs-keyword">break</span>;<br>   <span class="hljs-keyword">case</span> <span class="hljs-attr">value2</span>:<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-attr">default</span>:<br>    <span class="hljs-title function_">caseDidNotHappens</span>();<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p><strong>描述：</strong><br>一个 switch 语句首先会计算其 expression 。然后，它将从第一个 case 子句开始直到寻找到一个其表达式值与所输入的 expression 的值所相等的子句（使用 <code>严格运算符 </code>===）并将控制权转给该子句，执行相关语句。（如果多个 case 与提供的值匹配，则选择匹配的第一个 case，即使这些 case 彼此间并不相等。）</p><p>如果没有 case 子句相匹配，程序则会寻找那个可选的 default 子句，如果找到了，将控制权交给它，执行相关语句。若没有 default 子句，程序将继续执行直到 switch 结束。按照惯例，default 子句是最后一个子句，不过也不需要这样做。</p><p>可选的 break 语句确保程序立即从相关的 case 子句中跳出 switch 并接着执行 switch 之后的语句。若 break 被省略，程序会继续执行 switch 语句中的下一条语句。</p>          </div><h3 id="4-2-indexOf">4.2 indexOf()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">arr.<span class="hljs-title function_">indexOf</span>(searchElement[, fromIndex])<br></code></pre></td></tr></table></figure><blockquote><p>该方法将从头到尾地检索字符串 arr，看它是否含有子串 searchElement。开始检索的位置在字符串的 fromIndex 处或字符串的开头（没有指定 fromIndex 时）。如果找到一个 searchElement，则返回 searchElement 的第一次出现的位置。arr 中的字符位置是从 0 开始的。</p></blockquote><div class="note note-info">            <p><strong>提示和注释：</strong></p><p><em><strong>注释：</strong></em><br>indexOf() 方法对大小写敏感。</p><p>fromIndex 开始查找的位置。<br>如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回 -1。<br>如果参数中提供的索引值是一个负值，则将其作为数组末尾的一个抵消，即 -1 表示从最后一个元素开始查找，-2 表示从倒数第二个元素开始查找 ，以此类推。</p><p><em><strong>描述：</strong></em><br>indexOf 使用<code>严格相等运算符</code> 进行判断 searchElement 与数组中包含的元素之间的关系。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
      <category>学习笔记</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>===</tag>
      
      <tag>严格相等运算符</tag>
      
      <tag>==</tag>
      
      <tag>相等运算符</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈IEEE 754标准的浮点数误差成因</title>
    <link href="/2022/06/10/%E6%B5%85%E8%B0%88IEEE754%E6%A0%87%E5%87%86%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AF%AF%E5%B7%AE%E6%88%90%E5%9B%A0/"/>
    <url>/2022/06/10/%E6%B5%85%E8%B0%88IEEE754%E6%A0%87%E5%87%86%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AF%AF%E5%B7%AE%E6%88%90%E5%9B%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-IEEE-754标准的产生">1. IEEE 754标准的产生</h2><p>20 世纪 80 年代（没有制定 IEEE 754 标准）之前，业界还没有一个统一的浮点数标准。相反，很多计算机制造商根据自己的需要来设计自己的浮点数表示规则，以及浮点数的执行运算细节。另外，他们常常并不太关注运算的精确性，而把实现的速度和简易性看得比数字的精确性更重要，而这就给代码的可移植性造成了重大的障碍。</p><p>直到 1976 年，Intel 公司打算为其 8086 微处理器引进一种浮点数协处理器时，意识到作为芯片设计者的电子工程师和固体物理学家也许并不能通过数值分析来选择最合理的浮点数二进制格式。于是，他们邀请加州大学伯克利分校的 William Kahan 教授（当时最优秀的数值分析家）来为 8087 浮点处理器（FPU）设计浮点数格式。而这时，William Kahan 教授又找来两个专家协助他，于是就有了 KCS 组合（Kahn、Coonan和Stone），并共同完成了 Intel 公司的浮点数格式设计。</p><p>由于 Intel 公司的 KCS 浮点数格式完成得如此出色，以致 IEEE（Institute of Electrical and Electronics Engineers，电子电气工程师协会）决定采用一个非常接近 KCS 的方案作为 IEEE 的标准浮点格式。于是，IEEE 于 1985 年制订了二进制浮点运算标准 IEEE 754（IEEE Standard for Binary Floating-Point Arithmetic，ANSI/IEEE Std 754-1985），该标准限定指数的底为 2，并于同年被美国引用为 ANSI 标准。目前，几乎所有的计算机都支持 IEEE 754 标准，它大大地改善了科学应用程序的可移植性。</p><p>考虑到 IBM System/370 的影响，IEEE 于 1987 年推出了与底数无关的二进制浮点运算标准 IEEE 854，并于同年被美国引用为 ANSI 标准。1989 年，国际标准组织 IEC 批准 IEEE 754/854 为国际标准 IEC 559：1989。后来经修订后，标准号改为 IEC 60559。现在，几乎所有的浮点处理器完全或基本支持 IEC 60559。同时，C99 的浮点运算也支持 IEC 60559。</p><h2 id="2-标准浮点格式">2. 标准浮点格式</h2><p>IEEE 754标准准确地定义了单精度和双精度浮点格式，并为这两种基本格式分别定义了扩展格式，如下所示：</p><blockquote><ul><li>单精度浮点格式（32 位）。</li><li>双精度浮点格式（64 位）。</li><li>扩展单精度浮点格式（≥43 位，不常用）。</li><li>扩展双精度浮点格式（≥79 位，一般情况下，Intel x86 结构的计算机采用的是 80 位，而 SPARC 结构的计算机采用的是 128 位）。</li></ul></blockquote><p>其中，只有 32 位单精度浮点数是本标准强烈要求支持的，其他都是可选部分。本文主要针对单精度浮点与双精度浮点的存储格式做一些简要的阐述。</p><h3 id="2-1-什么是浮点误差">2.1 什么是浮点误差</h3><p>很多人在写代码时中都曾经遇到过所谓的浮点误差，以js为例来看0.1+0.2结果是什么：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;浮点误差：&quot;</span> + <span class="hljs-string">&quot;\n&quot;</span> + <span class="hljs-string">&quot;0.1+0.2=&quot;</span> + <span class="hljs-string">&quot;\n&quot;</span> + (<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>));<br><span class="hljs-comment">//浮点误差：</span><br><span class="hljs-comment">//0.1+0.2=</span><br><span class="hljs-comment">//0.30000000000000004</span><br></code></pre></td></tr></table></figure><p>正常情况下应该是0.1+0.2=0.3，但为什么运算结果却不是呢，这并不是什么bug，也并不是程序设计有问题，这个原因与浮点数的存储原理有关。在开始了解浮点数的存储原理前，需要先知道js中数值是以何种形式存储的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs info">JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。<br>所以，1与1.0是相同的，是同一个数。<br><br>1 === 1.0 // true<br><br>这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。<br>容易造成混淆的是，某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，<br>然后再进行运算。<br><br>由于浮点数不是精确的值，所以js中涉及小数的比较和运算要特别小心。<br></code></pre></td></tr></table></figure><h3 id="2-2-计算机中是如何存储整数的">2.2 计算机中是如何存储整数的</h3><p>在了解为什么会产生浮点误差前，我们先了解一下计算机是如何用0和1来表示一个整数的。我们知道计算机主要是采用二进制计算和存储数据的，我们假设一个<code>32bit</code>的无符号整数（unsigned integer），那么就是说它有32个位置来存放0或1，那么它的值的范围就是0~2<sup>32</sup>-1，即0~4294967295，也就是说它可以精确的表达出0~4294967295之间任意整数而不会有误差。</p><p>同时，我们可以看得出虽然0~2<sup>32</sup>有很多整数，但个数毕竟是有限的，但是浮点数就不同了，它可以有例如，2.1，2.11，2.111…等等无数个浮点数。那么该如何把这些无限的浮点数塞进有限的<code>32bit</code>的空间里呢，在IEEE 754标准诞生前，各个CPU厂家发明了各种浮点数的表示方法，后来则是统一遵循这个标准进行设计。</p><h3 id="2-3-浮点数格式的正规化">2.3 浮点数格式的正规化</h3><p>浮点数在存储之前必需先进行符合IEEE 754的格式的正规化操作，即由一个有效数字乘以2的整数次幂得到,类似于十进制的科学计数法，下面举例说明：</p><blockquote><p>浮点数5.5如何进行格式正规化：<br>5.5=5+0.5<br>转化为二进制：<br>2<sup>2</sup>+2<sup>1</sup>+2<sup>-1</sup> 即 101.1<br>格式正规化：<br>1.011×2<sup>2</sup></p></blockquote><h3 id="2-4-十进制与二进制的转化">2.4 十进制与二进制的转化</h3><p>十进制数值转化为二进制方法之一：整数部分为留余数，倒排序；小数部分为乘以2，一直到全部转化整数为止，正排序。也可使用<a href="https://tool.oschina.net/hexconvert">在线进制转换工具</a></p><blockquote><p>十进制8.125转化为二进制：<br>整数部分：<br>8÷2=4 余数 <code>0</code>；4÷2=2 余数 <code>0</code>；2÷2=1 余数 <code>0</code>；最后剩余 <code>1</code>；倒排序二进制表示为 <code>1000</code><br>小数部分：<br>0.125×2=0.25 整数部分 <code>0</code>；0.25×2=0.5 整数部分 <code>0</code>；0.5×2=1 整数部分 <code>1</code>；正序二进制表示为 <code>001</code><br>因此十进制<code>8.125</code>转化为二进制为 <code>1000.001</code></p></blockquote><h3 id="2-5-浮点数的表示法">2.5 浮点数的表示法</h3><p>一个浮点数分为三个部分，分别是符号位（sign bit），指数偏移值(exponent bias)，分数值(fraction)。浮点数的值(value)=符号位（sign bit）×指数偏移值(exponent bias)×有效数(fraction)。</p><blockquote><p>符号(S) :用來表示正/负(0/1)。<br>指数(E) :浮点数正规化后的次方，单精度的指数部分采用超127格式，即将原本的次方数加上127，因为次方数有可能是负的，加上计算机要表示负号时，必须拿一个位元来表示，所以就将-128~+127改为0~255，所以基准点就从0变成127。双精度的指数部分是−1022～+1023加上1023，指数值的大小从1～2046（0（2进位全为0）和2047（2进位全为1）是特殊值）。浮点小数计算时，指数值减去偏正值将是实际的指数大小。<br>有效数(F) :正规化后小数点之后的值。</p></blockquote><h4 id="单精度浮点数-float">单精度浮点数(float)</h4><p><img src="1-1.jpg" alt="单精度浮点数表示法"><br>sign：最左侧<code>1bit</code> 代表正负号，正数的话<code>sign</code>就为<code>0</code>，反之则是 <code>1</code><br>exponent：中间的<code>8bit</code>代表正规化后的次方数，采用的是<code>超127格式</code>，也就是<code>次方数</code>还要再加上<code>127</code><br>fraction：最右侧的<code>23bit</code> 放的是小数部分，以<code>1.0001</code>来说就是去掉<code>1.</code>之后的<code>0001</code></p><p>我们以<code>8.125</code>为例，表示成IEEE 754标准的<code>32bit</code>格式：</p><blockquote><p>正规化：8.125=+1.000001×2<sup>3</sup></p></blockquote><table><thead><tr><th>Sign</th><th>Exponent</th><th>Fraction</th></tr></thead><tbody><tr><td>0 (+)</td><td>1000 0010 (3+127=130)</td><td>0000 0100 0000 0000 0000 000</td></tr></tbody></table><blockquote><p>二进制表示：0100 0001 0000 0010 0000 00000 0000 0000</p></blockquote><p>0.1 + 0.2 != 0.3的原因就在于0.1、0.2和0.3分别用二进制表示时，均无法转化成2的次方数相加，最后产生不同误差。</p><p>有兴趣可以到<a href="https://www.h-schmidt.net/FloatConverter/IEEE754.html">IEEE-754 Floating Point Converter</a>官网测试。</p><h4 id="双精度浮点数-double">双精度浮点数(double)</h4><p>为了让误差更小，<code>IEEE 754</code>也定义了如何用<code>64bit</code>来表示浮点数，跟<code>32bit</code>比起来<code>fraction</code>部分大了超过两倍，从<code>23bit</code>变成<code>52bit</code>，所以精准度自然提高许多。</p><p><img src="1-2.jpg" alt="双精度浮点数表示法"><br>sign：最左侧<code>1bit</code> 代表正负号，正数的话<code>sign</code>就为<code>0</code>，反之则是 <code>1</code><br>exponent：中间的<code>1bit</code>代表正规化后的次方数，采用的是<code>超1023格式</code>，也就是<code>次方数</code>还要再加上<code>1023</code><br>fraction：最右侧的<code>52bit</code> 放的是小数部分，以<code>1.0001</code>来说就是去掉<code>1.</code>之后的<code>0001</code></p><p><img src="2.jpg" alt="单双精度浮点数的对比"></p><h3 id="2-6-如何解决浮点数误差">2.6 如何解决浮点数误差</h3><p>1、设定一个最大允许误差值（EPSILON）<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON">例如ES6中内置的Number.EPSILON</a></p><blockquote><p>例如把 0.1 + 0.2 == 0.3改写成 0.1 + 0.2 — 0.3 &lt;= epsilon</p></blockquote><p>2、完全使用十进制进行计算，但不建议大规模使用，因为十进制计算是组件模拟出来的，CPU计算时仍会转化为二进制，会拖慢运算速度。</p><!-- $$E=mc^2$$ --><!-- ```mermaid --><!-- classDiagramClass01 <|-- AveryLongClass : CoolClass03 *-- Class04Class05 o-- Class06Class07 .. Class08Class09 --|> C2 : Where am i?Class09 --* C3Class09 --|> Class07Class07 : equals()Class07 : Object[] elementDataClass01 : size()Class01 : int chimpClass01 : int gorillaClass08 <--|> C2: Cool label --><!-- ``` --><!-- <a class="btn" href="url" title="title">text</a> -->]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
      <category>学习笔记</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IEEE754</tag>
      
      <tag>浮点数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>条件语句和循环语句</title>
    <link href="/2022/06/07/%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"/>
    <url>/2022/06/07/%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="1-条件语句">1. 条件语句</h2><p>JavaScript提供 <a href="">if</a> 结构和 <a href="">switch</a> 结构，用以完成条件判断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs parsing">即只有满足预设的条件，才会执行相应的语句。<br></code></pre></td></tr></table></figure><h3 id="1-1-if-结构">1.1 <a href="">if</a> 结构</h3><p>if 结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句。所谓布尔值，指的是 JavaScript 的两个特殊值，true表示“真”，false表示“伪”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (布尔值)<br>  语句;<br><br><span class="hljs-comment">// 或者</span><br><span class="hljs-keyword">if</span> (布尔值) 语句;<br></code></pre></td></tr></table></figure><p>上面这种写法要求条件表达式后面只能有一个语句。如果想执行多个语句，必须在if的条件判断之后，加上大括号，表示代码块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (布尔值) &#123;<br>  语句一;<br>  语句二;<br>  ...<br>  语句N;<br>&#125;<br></code></pre></td></tr></table></figure><p>建议总是在if语句中使用大括号，因为这样方便插入语句。</p><h3 id="1-2-if…else-结构">1.2 <a href="">if…else</a> 结构</h3><p>if代码块后面，还可以跟一个else代码块，表示不满足条件时，所要执行的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (布尔值) &#123;<br>  <span class="hljs-comment">// 满足条件时，执行的语句</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 不满足条件时，执行的语句</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对同一个变量进行多次判断时，多个if…else语句可以连写在一起。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (条件一) &#123;<br>  <span class="hljs-comment">// 满足条件一执行</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (条件二) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (条件三) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>else代码块总是与离自己最近的那个if语句配对。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> m = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> n = <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">if</span> (m !== <span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> (n === <span class="hljs-number">2</span>) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;world&#x27;</span>);<br></code></pre></td></tr></table></figure><p>上面代码不会有任何输出，else代码块不会得到执行，因为它跟着的是最近的那个if语句，相当于下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (m !== <span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;world&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果想让else代码块跟随最上面的那个if语句，就要改变大括号的位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (m !== <span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>  &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;world&#x27;</span>);<br>&#125;<br><span class="hljs-comment">// world</span><br></code></pre></td></tr></table></figure><h3 id="1-3-switch-结构">1.3 <a href="">switch</a> 结构</h3><p>多个<a href="">if…else</a>连在一起使用的时候，可以转为使用更方便的<a href="">switch</a>结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">switch</span> (x) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;x 等于1&#x27;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;x 等于2&#x27;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-attr">default</span>:<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;x 等于其他值&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码根据变量x的值，选择执行相应的case。如果所有case都不符合，则执行最后的default部分。需要注意的是，每个case代码块内部的break语句不能少，否则会接下去执行下一个case代码块，而不是跳出switch结构。</p><p>switch语句部分和case语句部分，都可以使用表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">switch</span> (<span class="hljs-number">1</span> + <span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span> + <span class="hljs-number">2</span>:<br>    <span class="hljs-title function_">fn</span>();<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-attr">default</span>:<br>    <span class="hljs-title function_">neverHappens</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>switch表达式与case表示式比较运行结果时，采用的是 <strong>严格相等运算符（===）</strong>，而不是 <strong>相等运算符（==）</strong>，这意味着比较时 <em>不会发生</em> 类型转换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">switch</span> (x) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-attr">true</span>:<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;x 发生类型转换&#x27;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-attr">default</span>:<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;x 没有发生类型转换&#x27;</span>);<br>&#125;<br><span class="hljs-comment">// x 没有发生类型转换</span><br></code></pre></td></tr></table></figure><p>上面代码中，由于变量x <strong>没有发生类型转换</strong>，所以不会执行case true的情况。这表明，switch语句内部采用的是 <strong>严格相等运算符</strong>。</p><h3 id="1-4-三元运算符-结构">1.4 三元运算符<a href="">? :</a> 结构</h3><p>JavaScript 还有一个三元运算符（即该运算符需要三个运算子）<a href="">? :</a>，也可以用于逻辑判断。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(条件) ? 表达式<span class="hljs-number">1</span> : 表达式<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>上面代码中，如果“条件”为true，则返回“表达式1”的值，否则返回“表达式2”的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> even = (n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><p>上面代码中，如果n可以被2整除，则even等于true，否则等于false。它等同于下面的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> even;<br><span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) &#123;<br>  even = <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  even = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个三元运算符可以被视为 <a href="">if…else…</a> 的简写形式，因此可以用于多种场合。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myVar;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>  myVar ?<br>  <span class="hljs-string">&#x27;myVar has a value&#x27;</span> :<br>  <span class="hljs-string">&#x27;myVar does not have a value&#x27;</span><br>)<br><span class="hljs-comment">// myVar does not have a value</span><br><br><span class="hljs-keyword">var</span> msg = <span class="hljs-string">&#x27;数字&#x27;</span> + n + <span class="hljs-string">&#x27;是&#x27;</span> + (n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> ? <span class="hljs-string">&#x27;偶数&#x27;</span> : <span class="hljs-string">&#x27;奇数&#x27;</span>);<br><br></code></pre></td></tr></table></figure><p>上面代码利用三元运算符，输出相应的提示和在字符串之中插入不同的值。</p><h2 id="2-循环语句">2. 循环语句</h2><p>循环语句用于重复执行某个操作，它有多种形式。</p><h3 id="2-1-while-循环">2.1 <a href="">while</a> 循环</h3><p><a href="">while</a> 语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">while</span> (条件)<br>  语句;<br><span class="hljs-comment">// 或者</span><br><span class="hljs-keyword">while</span> (条件) 语句;<br><br><span class="hljs-comment">//多条语句</span><br><span class="hljs-keyword">while</span> (条件) &#123;<br>  语句一;<br>  ...<br>  语句N;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>while语句的循环条件是一个表达式，必须放在圆括号中。代码块部分，如果只有一条语句，可以省略大括号，否则就必须加上大括号。</p><h3 id="2-2-for-循环">2.2 <a href="">for</a> 循环</h3><p><a href="">for</a> 语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。它的格式如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (初始化表达式; 条件; 递增表达式)<br>  语句<br><br><span class="hljs-comment">// 或者</span><br><br><span class="hljs-keyword">for</span> (初始化表达式; 条件; 递增表达式) &#123;<br>  语句<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="">for</a> 语句后面的括号里面，有三个表达式。</p><blockquote><p>~</p><ul><li>初始化表达式（initialize）：确定循环变量的初始值，只在循环开始时执行一次。</li><li>条件表达式（test）：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。</li><li>递增表达式（increment）：每轮循环的最后一个操作，通常用来递增循环变量。</li></ul><p>~</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; x; i++) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>&#125;<br><span class="hljs-comment">// 0</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>上面代码中，初始化表达式是var i = 0，即初始化一个变量i；测试表达式是i &lt; x，即只要i小于x，就会执行循环；递增表达式是i++，即每次循环结束后，i增大1。</p><p>所有for循环，都可以改写成while循环。上面的例子改为while循环，代码如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span> (i &lt; x) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  i++;<br>&#125;<br></code></pre></td></tr></table></figure><p>for语句的三个部分（initialize、test、increment），可以省略任何一个，也可以全部省略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> ( ; ; )&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello World&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码省略了for语句表达式的三个部分，结果就导致了一个无限循环。</p><h3 id="2-3-do…while-循环">2.3 <a href="">do…while</a> 循环</h3><p><a href="">do…while</a> 循环与 <a href="">while</a> 循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">do</span><br>  语句<br><span class="hljs-keyword">while</span> (条件);<br><br><span class="hljs-comment">// 或者</span><br><span class="hljs-keyword">do</span> &#123;<br>  语句<br>&#125; <span class="hljs-keyword">while</span> (条件);<br><br><span class="hljs-comment">//eg:</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">do</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  i++;<br>&#125; <span class="hljs-keyword">while</span>(i &lt; x);<br><span class="hljs-comment">//0</span><br><span class="hljs-comment">//1</span><br><span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure><p>不管条件是否为真，<a href="">do…while</a> 循环至少运行一次，这是这种结构最大的特点。另外，while语句后面的分号注意不要省略。</p><h3 id="2-4-break-语句和-continue-语句">2.4 <a href="">break</a> 语句和 <a href="">continue</a> 语句</h3><p><a href="">break</a> 语句和<a href="">continue</a> 语句都具有跳转作用，可以让代码不按既有的顺序执行。</p><p><a href="">break</a> 语句用于跳出代码块或循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span>(i &lt; <span class="hljs-number">100</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;i 当前为：&#x27;</span> + i);<br>  i++;<br>  <span class="hljs-keyword">if</span> (i === <span class="hljs-number">10</span>) <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码只会执行10次循环，一旦i等于10，就会跳出循环。</p><p>for循环也可以使用break语句跳出循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  <span class="hljs-keyword">if</span> (i === <span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">// 0</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>上面代码执行到i等于3，就会跳出循环。</p><p><a href="">continue</a> 语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">100</span>)&#123;<br>  i++;<br>  <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;i 当前为：&#x27;</span> + i);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码只有在i为奇数时，才会输出i的值。如果i为偶数，则直接进入下一轮循环。</p><p>如果存在多重循环，不带参数的 <a href="">break</a> 语句和 <a href="">continue</a> 语句都只针对最内层循环。</p><h3 id="2-5-标签（label-）">2.5 标签（<a href="">label</a> ）</h3><p>JavaScript 语言允许，语句的前面有标签（<a href="">label</a> ），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">label</span>:<br>  语句<br></code></pre></td></tr></table></figure><p>标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。</p><p>标签通常与 <a href="">break</a> 语句和 <a href="">continue</a> 语句配合使用，跳出特定的循环。</p><p>[eg:]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">top</span>:<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)&#123;<br>      <span class="hljs-keyword">if</span> (i === <span class="hljs-number">1</span> &amp;&amp; j === <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span> top;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;i=&#x27;</span> + i + <span class="hljs-string">&#x27;, j=&#x27;</span> + j);<br>    &#125;<br>  &#125;<br><span class="hljs-comment">// i=0, j=0</span><br><span class="hljs-comment">// i=0, j=1</span><br><span class="hljs-comment">// i=0, j=2</span><br><span class="hljs-comment">// i=1, j=0</span><br></code></pre></td></tr></table></figure><p>上面代码为一个双重循环区块，<a href="">break</a> 命令后面加上了 <a href="">top</a> 标签（注意，top不用加引号），满足条件时，直接跳出双层循环。如果break语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。</p><blockquote><p>标签也可以用于跳出代码块。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">foo</span>: &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">break</span> foo;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;本行不会输出&#x27;</span>);<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><blockquote><p>上面代码执行到break foo，就会跳出区块。</p></blockquote><p>continue语句也可以与标签配合使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">top</span>:<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)&#123;<br>      <span class="hljs-keyword">if</span> (i === <span class="hljs-number">1</span> &amp;&amp; j === <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span> top;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;i=&#x27;</span> + i + <span class="hljs-string">&#x27;, j=&#x27;</span> + j);<br>    &#125;<br>  &#125;<br><span class="hljs-comment">// i=0, j=0</span><br><span class="hljs-comment">// i=0, j=1</span><br><span class="hljs-comment">// i=0, j=2</span><br><span class="hljs-comment">// i=1, j=0</span><br><span class="hljs-comment">// i=2, j=0</span><br><span class="hljs-comment">// i=2, j=1</span><br><span class="hljs-comment">// i=2, j=2</span><br></code></pre></td></tr></table></figure><p>上面代码中，<a href="">continue</a> 命令后面有一个标签名，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果continue语句后面不使用标签，则只能进入下一轮的内层循环</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
      <category>学习笔记</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>条件语句</tag>
      
      <tag>循环语句</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
