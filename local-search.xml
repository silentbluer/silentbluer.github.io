<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JavaScript的数据类型浅析</title>
    <link href="/2022/06/16/JavaScript%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%B5%85%E6%9E%90/"/>
    <url>/2022/06/16/JavaScript%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%B5%85%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-数据类型的概述">1. 数据类型的概述</h2><p>JavaScript类型可以分为两类：原始类型和对象类型。</p><h3 id="1-1-原始类型">1.1 原始类型</h3><blockquote><ul><li>JavaScript的原始类型包括 <strong>数值</strong> 、<strong>文本字符串</strong>（也称字符串）和 <strong>布尔真值</strong>（也称布尔值）。</li><li>JavaScript中的特殊值 <strong>null</strong> 和 <strong>undefined</strong> 也是原始值，但它们不是数值、字符串或布尔值。这两个值通常被认为是各自特殊类型的唯一成员。</li><li>ES6新增了一种特殊类型 <strong>Symbol</strong>（符号），用于对语言进行扩展而不破坏向后兼容性。</li></ul></blockquote><h3 id="1-2-对象类型">1.2 对象类型</h3><p>在JavaScript中，任何不是<strong>数值</strong>、<strong>字符串</strong>、<strong>布尔值</strong>、<strong>符号</strong>、<strong>null</strong>和<strong>undefined</strong>的值都是<strong>对象</strong>。</p><p><strong>对象</strong><small>（<u>也就是对象类型的成员</u>）</small>是 <em>属性</em> 的集合，其中每个<code>属性</code>都有一个<code>名字</code>和一个<code>值</code><small>（<u>原始值或其他对象</u>）</small>。</p><blockquote><ul><li>普通JavaScript对象是一个命名值的无序集合。</li><li>JavaScript自身定义了一种特殊对象，称为数组。数组表示一个数字值的有序集合。</li></ul></blockquote><div class="note note-info">            <blockquote><p>除了基本的<code>对象</code>和<code>数组</code>之外，JavaScript还定义了其他一些有用的对象类型。</p></blockquote><ul><li>Set对象表示一组值的集合，Map对象表示键与值的映射。</li><li>各种“定型数组”（typed array）类型便于对字节数组和其他二进制数据进行操作。</li><li>RegExp类型表示文本模式，可以实现对字符串的复杂匹配、搜索和替换操作。</li><li>Date类型表示日期和时间，支持基本的日期计算。</li><li>Error及其子类型表示JavaScript代码运行期间可能发生的错误。</li></ul>          </div><h3 id="1-3-数据类型特点">1.3 数据类型特点</h3><p>JavaScript的<code>对象类型</code>是可修改的（mutable），而它的<code>原始类型</code>是不可修改的（immutable）。</p><p>可修改类型的值可以改变，比如JavaScript程序可以修改对象属性和数组元素的值。</p><p><strong>数值</strong>、<strong>布尔值</strong>、<strong>符号</strong>、<strong>null</strong>和<strong>undefined</strong>是不可修改的，以数值为例，修改它是没有意义的。</p><p><strong>字符串</strong>可以看成字符数组，<u>字符串也是<span style="color:red;">不可</span>修改的</u>。虽然可以按索引访问字符串中的字符，但JavaScript没有提供任何方式去修改已有字符串的字符。</p><blockquote><p>常量和变量可以让我们在程序中使用名字来引用其值。</p></blockquote><p>常量使用<code>const</code>声明，变量使用<code>let</code>（或在较老的JavaScript代码中使用var）声明。<br>JavaScript常量和变量是无类型的（untyped），声明并不会限定要赋何种类型的值。</p><h2 id="2-数值">2. 数值</h2><h3 id="2-1-特点">2.1 特点</h3><p>JavaScript的主要数值类型Number用于表示整数和近似实数。JavaScript使用IEEE 754标准<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://blog.silentblue.top/2022/06/10/浅谈IEEE754标准的浮点数误差成因/">[1]</span></a></sup>定义的64位浮点格式表示数值，这种数值格式可以让我们准确表示-9 007 199 254 740 992（-2<sup>53</sup>）到9 007 199 254 740 992（2<sup>53</sup>）之间的所有整数（含首尾值）。如果你的数值超出了这个范围，那可能会在末尾的数字上损失一些精度。</p><p>但要注意，JavaScript中的某些操作（如数组索引和位操作）是以32位整数计算的。当数值真正出现在JavaScript程序中时，就叫作数值字面量（numeric literal）。JavaScript支持几种形式的数值字面量，任何数值字面量前面都可以加上一个减号（-）将数值变成负值。</p><h3 id="2-2-数值的进制与表示方法">2.2 数值的进制与表示方法</h3><p>在JavaScript程序中，基数为10的整数可以直接写成数字序列。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">3</span><br><span class="hljs-number">5</span><br><span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure><p>除了基数为10的整数字面量之外，JavaScript也支持十六进制（基数是16的）值。十六进制字面量以<code>0x</code>或<code>0X</code>开头，后跟一个十六进制数字字符串。十六进制数字是数字<code>0</code>到<code>9</code>和字母<code>a（或A）</code>到<code>f（或F）</code>，<code>a到f</code>表示<code>10到15</code>。下面是十六进制整数字面量的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">0xff</span> <span class="hljs-comment">// 255</span><br><span class="hljs-number">0o377</span> <span class="hljs-comment">// 255</span><br><span class="hljs-number">0b11</span> <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>在ES6及之后的版本中，也可以通过<code>二进制</code>（基数为2）或<code>八进制</code>（基数为8）表示整数，分别使用前缀<code>0b</code>和<code>0o</code>（或<code>0B</code>和<code>0O</code>）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">0b10101</span> <span class="hljs-comment">// 21 (1*16+0*8+1*4+0*2+1*1)</span><br><span class="hljs-number">0o377</span> <span class="hljs-comment">// 255 (3*64+7*8+7*1)</span><br></code></pre></td></tr></table></figure><div class="note note-info">            <table><thead><tr><th style="text-align:right">进制</th><th style="text-align:right">表示方法</th><th style="text-align:right">注意</th></tr></thead><tbody><tr><td style="text-align:right">二进制</td><td style="text-align:right">0b/0B</td><td style="text-align:right">默认情况下，JavaScript 内部会自动将八进制、十六进制、二进制转为十进制。</td></tr><tr><td style="text-align:right">八进制</td><td style="text-align:right">0o/0O</td><td style="text-align:right">如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报错。</td></tr><tr><td style="text-align:right">十进制</td><td style="text-align:right">无</td><td style="text-align:right">通常来说，有前导0的数值会被视为八进制，但是如果前导0后面有数字8和9，则该数值被视为十进制。</td></tr><tr><td style="text-align:right">十六进制</td><td style="text-align:right">0x/0X</td><td style="text-align:right">前导0表示八进制，处理时很容易造成混乱。ES5 的严格模式和 ES6，已经废除了这种表示法，但是浏览器为了兼容以前的代码，目前还继续支持这种表示法。</td></tr></tbody></table>          </div><p>浮点字面量可以包含小数点，它们对实数使用传统语法。实数值由数值的整数部分、小数点和数值的小数部分组成。</p><p>浮点字面量也可以使用指数记数法表示，即实数值后面可以跟字母e（或E），跟一个可选的加号或减号，再跟一个整数指数。这种记数法表示的是实数值乘以10的指数次幂。</p><blockquote><p>简明格式：<br>[digits][.digits][(E/e)[(+/-)]digits]</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">123e3</span> <span class="hljs-comment">// 123000 </span><br><span class="hljs-number">123e-3</span> <span class="hljs-comment">// 0.123</span><br>-<span class="hljs-number">3.1E+12</span><br><span class="hljs-number">.1e-23</span><br></code></pre></td></tr></table></figure><p>以下两种情况，JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示：</p><div class="note note-info">            <table><thead><tr><th style="text-align:right">规则</th><th style="text-align:right">实例</th></tr></thead><tbody><tr><td style="text-align:right">小数点前的数字<code>大于&gt;</code>21位</td><td style="text-align:right">1234567890123456789012  /=&gt; 1.2345678901234568e+21</td></tr><tr><td style="text-align:right">小数点后0<code>大于&gt;</code>5个</td><td style="text-align:right">0.0000003 /=&gt; 3e-7</td></tr></tbody></table>          </div><p><strong>数值字面量中的分隔符：</strong></p><p>可以用下划线将数值字面量分隔为容易看清的数字段：</p><blockquote><p>字节(byte)是计算机中数据处理的基本单位。 计算机中以字节(byte)为单位存储和解释信息，规定一个字节(byte)由八个二进制位构成，即1个字节等于8个比特（1Byte=8bit）。八位二进制数最小为0000_0000，最大为1111_1111；通常1个字节可以存入一个ASCII码，2个字节可以存放一个汉字国标码。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> billion = <span class="hljs-number">1_000_000_000</span>; <span class="hljs-comment">//以下划线作为千分位分隔符</span><br><span class="hljs-keyword">let</span> bytes = <span class="hljs-number">0X89_AB_CD_EF</span>;  <span class="hljs-comment">//作为字节分隔符</span><br><span class="hljs-keyword">let</span> bits = <span class="hljs-number">0b0001_1101_0111</span>; <span class="hljs-comment">//作为半字节分隔符</span><br><span class="hljs-keyword">let</span> fraction = <span class="hljs-number">0.123_456_789</span> <span class="hljs-comment">//作为小数部分分隔符</span><br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>数值字面量中像这样添加下划线还没有成为正式的JavaScript标准。但这个特性已经进入标准化流程的后期，而且已经被所有主流浏览器以及Node实现了。</p>          </div><h3 id="2-3-数学方法">2.3 数学方法</h3><p>JavaScript程序的算术操作符包括表示<code>加法</code>的<code>+</code>、表示<code>减法</code>的<code>-</code>、表示<code>乘法</code>的<code>*</code>、表示<code>除法</code>的<code>/</code>和表示<code>取模（除法后的余数）</code>的<code>%</code>。ES2016增加了<code>取幂</code>的<code>**</code>。</p><blockquote><p><code>幂</code>在数学里表示次方，求幂运算符（**）返回将第一个操作数加到第二个操作数的幂的结果(a ** b = a<sup>b</sup>)。<br><code>**</code>等效于Math.pow(a,b)，不同之处在于它也接受 BigInts 作为操作数。<br><code>**</code>是右结合的: a ** b ** c 等于 a ** (b ** c)<br>在 JavaScript里，不能将一个一元运算符（+/-/~/!/delete/void/typeof）放在基数前，会导致一个语法错误。</p></blockquote><!-- <span class="label label-warning">求幂运算符是是右结合的: a ** b ** c 等于 a ** (b ** c)</span> --><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span> ** <span class="hljs-number">4</span>);<br><span class="hljs-comment">// expected output: 81</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">10</span> ** -<span class="hljs-number">2</span>);<br><span class="hljs-comment">// expected output: 0.01</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span> ** <span class="hljs-number">3</span> ** <span class="hljs-number">2</span>);<br><span class="hljs-comment">// expected output: 512 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-number">2</span> ** <span class="hljs-number">3</span>) ** <span class="hljs-number">2</span>);<br><span class="hljs-comment">// expected output: 64</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(-<span class="hljs-number">2</span> ** <span class="hljs-number">3</span>);<br><span class="hljs-comment">// SyntaxError  语法错误</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(-(<span class="hljs-number">2</span> ** <span class="hljs-number">3</span>));<br><span class="hljs-comment">// expected output: -8</span><br></code></pre></td></tr></table></figure><p>除了上述基本的算术操作符之外，JavaScript还通过Math对象的属性提供了一组函数和常量，以支持更复杂的数学计算：</p><div class="note note-primary">            <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>) <span class="hljs-comment">// =&gt; 64,2的5次方  &lt;==&gt;  2 ** 5</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(<span class="hljs-number">0.5</span>) <span class="hljs-comment">// =&gt;1,舍入到最近的整数</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(<span class="hljs-number">0.3</span>) <span class="hljs-comment">// =&gt;1,向上舍入到一个整数</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-number">0.8</span>) <span class="hljs-comment">// =&gt;0,向下舍入到一个整数</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(-<span class="hljs-number">5</span>) <span class="hljs-comment">// =&gt;5,取绝对值</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(x,y,z) <span class="hljs-comment">// 返回最大的参数</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(x,y,z) <span class="hljs-comment">// 返回最小的参数</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() <span class="hljs-comment">// 伪随机数x,其中0 ≤ x ＜ 1.0</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> <span class="hljs-comment">//圆周率Π</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-property">E</span> <span class="hljs-comment">// 自然对数的底数e,数学中常以logx表示自然对数</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">// &lt;==&gt; Math.pow(3,(1/2)) =&gt; 3 ** 0.5，求3的平方根</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>/<span class="hljs-number">3</span>) <span class="hljs-comment">// 3 ** (1/3),求3的立方根</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(<span class="hljs-number">0</span>) <span class="hljs-comment">// 三角函数，类似还有Math.acos()、Math.asin()、Math.atan()、</span><br>            <span class="hljs-comment">// Math.atan2()、Math.cos()、Math.tan()等</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">10</span>) <span class="hljs-comment">// 10的自然对数，此处底数应为e</span><br><span class="hljs-comment">/*  </span><br><span class="hljs-comment">1、a^x=N(a&gt;0,且a≠1)，则x叫做以a为底N的对数,记做x=log(a)(N)，其中a要写于log右下。</span><br><span class="hljs-comment">2、其中a叫做对数的底，N叫做真数。通常我们将以10为底的对数叫做常用对数，以e为底的对数称为自然对数。</span><br><span class="hljs-comment">3、log的底数是10时可以写成lg，底数是e时可以简写成ln。</span><br><span class="hljs-comment">4、log不写底数时，通场需结合上下文判断底数，但一般规律为：通常情况下是10；</span><br><span class="hljs-comment">计算机学科中是2（在计算时间复杂度时，底数可以忽略）；而编程语言中则是e。</span><br><span class="hljs-comment"> */</span> <br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">88</span>)/<span class="hljs-title class_">Math</span>.<span class="hljs-property">LN10</span> <span class="hljs-comment">// 以10为底，88的对数</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">88</span>)/<span class="hljs-title class_">Math</span>.<span class="hljs-property">LN2</span> <span class="hljs-comment">// 以2为底，88的对数</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">exp</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">// e^3,Math.E的立方</span><br></code></pre></td></tr></table></figure>          </div><span class="label label-warning">JS中的Math对象还有很多，ES6在Math对象上又新增了一批函数，有兴趣可自行研究JS中的Math对象<sup id=fnref:2 class=footnote-ref><a href=#fn:2 rel=footnote><span class=hint--top hint--rounded aria-label=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math>[2]</span></a></sup></span><h3 id="2-4-特殊数值">2.4 特殊数值</h3><div class="note note-info">            <blockquote><p>1、JavaScript中的算术在遇到<code>上溢出</code>、<code>下溢出</code>或<code>被零除</code>时不会发生错误。<br>在数值操作的结果超过最大可表示数值时（上溢出），结果是一个特殊的无穷值<code>Infinity</code>。<br>2、当某个负数的绝对值超过了最大可表示负数的绝对值时，结果是负无穷值<code>-Infinity</code>。<br><span class="label label-warning">这两个无穷值的行为跟我们的预期一样：任何数<code>加、减、乘、除</code>无穷值结果还是无穷值（只是符号可能相反）。</span></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">0</span>乘以<span class="hljs-title class_">Infinity</span>，返回<span class="hljs-title class_">NaN</span>；<span class="hljs-number">0</span>除以<span class="hljs-title class_">Infinity</span>，返回<span class="hljs-number">0</span>；<span class="hljs-title class_">Infinity</span>除以<span class="hljs-number">0</span>，返回<span class="hljs-title class_">Infinity</span>。<br><span class="hljs-number">0</span> * <span class="hljs-title class_">Infinity</span> <span class="hljs-comment">// NaN</span><br><span class="hljs-number">0</span> / <span class="hljs-title class_">Infinity</span> <span class="hljs-comment">// 0</span><br><span class="hljs-title class_">Infinity</span> / <span class="hljs-number">0</span> <span class="hljs-comment">// Infinity</span><br><br><span class="hljs-title class_">Infinity</span>加上或乘以<span class="hljs-title class_">Infinity</span>，返回的还是<span class="hljs-title class_">Infinity</span>。<br><span class="hljs-title class_">Infinity</span> + <span class="hljs-title class_">Infinity</span> <span class="hljs-comment">// Infinity</span><br><span class="hljs-title class_">Infinity</span> * <span class="hljs-title class_">Infinity</span> <span class="hljs-comment">// Infinity</span><br><br><span class="hljs-title class_">Infinity</span>减去或除以<span class="hljs-title class_">Infinity</span>，得到<span class="hljs-title class_">NaN</span>。<br><span class="hljs-title class_">Infinity</span> - <span class="hljs-title class_">Infinity</span> <span class="hljs-comment">// NaN</span><br><span class="hljs-title class_">Infinity</span> / <span class="hljs-title class_">Infinity</span> <span class="hljs-comment">// NaN</span><br><br><span class="hljs-title class_">Infinity</span>与<span class="hljs-literal">null</span>计算时，<span class="hljs-literal">null</span>会转成<span class="hljs-number">0</span>，等同于与<span class="hljs-number">0</span>的计算。<br><span class="hljs-literal">null</span> * <span class="hljs-title class_">Infinity</span> <span class="hljs-comment">// NaN</span><br><span class="hljs-literal">null</span> / <span class="hljs-title class_">Infinity</span> <span class="hljs-comment">// 0</span><br><span class="hljs-title class_">Infinity</span> / <span class="hljs-literal">null</span> <span class="hljs-comment">// Infinity</span><br><br><span class="hljs-title class_">Infinity</span>与<span class="hljs-literal">undefined</span>计算，返回的都是<span class="hljs-title class_">NaN</span>。<br><span class="hljs-literal">undefined</span> + <span class="hljs-title class_">Infinity</span> <span class="hljs-comment">// NaN</span><br><span class="hljs-literal">undefined</span> - <span class="hljs-title class_">Infinity</span> <span class="hljs-comment">// NaN</span><br><span class="hljs-literal">undefined</span> * <span class="hljs-title class_">Infinity</span> <span class="hljs-comment">// NaN</span><br><span class="hljs-literal">undefined</span> / <span class="hljs-title class_">Infinity</span> <span class="hljs-comment">// NaN</span><br><span class="hljs-title class_">Infinity</span> / <span class="hljs-literal">undefined</span> <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><p>3、下溢出发生在数值操作的结果比最小可表示数值更接近0的情况下。此时，JavaScript返回0。如果下溢出来自负数，JavaScript返回一个被称为“负零”的特殊值。这个值与常规的零几乎完全无法区分，几乎所有场合，正零和负零都会被当作正常的0。唯一有区别的场合是，+0或-0当作分母，返回的值是不相等的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">-<span class="hljs-number">0</span> === +<span class="hljs-number">0</span> <span class="hljs-comment">// true</span><br><span class="hljs-number">0</span> === -<span class="hljs-number">0</span> <span class="hljs-comment">// true</span><br><span class="hljs-number">0</span> === +<span class="hljs-number">0</span> <span class="hljs-comment">// true</span><br>(<span class="hljs-number">1</span> / +<span class="hljs-number">0</span>) === (<span class="hljs-number">1</span> / -<span class="hljs-number">0</span>) <span class="hljs-comment">// false</span><br><span class="hljs-comment">//上面的代码之所以出现这样结果，是因为除以正零得到+Infinity，</span><br><span class="hljs-comment">//除以负零得到-Infinity，这两者是不相等的</span><br></code></pre></td></tr></table></figure><p>4、被零除在JavaScript中不是错误，只会简单地返回<code>无穷(infinity)</code>或<code>负无穷(-infinity)</code>。<br>5、不过有一个例外：<code>0/0</code>是没有意义的值，这个操作的结果是一个特殊的“非数值”（<code>NaN</code>，Not a Number）。此外，<code>无穷除无穷(infinity/infinity)</code>、<code>负数平方根(Math.sqrt(-x))</code>或者用<code>无法转换为数值</code>的非数值作为算术操作符<code>的操作数</code>，结果也都是NaN。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">5</span> - <span class="hljs-string">&#x27;x&#x27;</span> <span class="hljs-comment">// NaN,代码运行时，会自动将字符串x转为数值，但是由于x不是数值，所以最后得到结果为NaN,</span><br><span class="hljs-comment">//用`无法转换为数值`的非数值作为算术操作符`的操作数`</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">acos</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">log</span>(-<span class="hljs-number">1</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(-<span class="hljs-number">1</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-number">0</span> / <span class="hljs-number">0</span> <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><p>6、需要注意的是，NaN不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于Number，使用typeof运算符可以看得很清楚。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">NaN</span> <span class="hljs-comment">// &#x27;number&#x27;</span><br></code></pre></td></tr></table></figure><p>7、NaN在布尔运算时被当作false。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Boolean</span>(<span class="hljs-title class_">NaN</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>8、NaN与任何数（包括它自己）的运算，得到的都是NaN。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">NaN</span> + <span class="hljs-number">32</span> <span class="hljs-comment">// NaN</span><br><span class="hljs-title class_">NaN</span> - <span class="hljs-number">32</span> <span class="hljs-comment">// NaN</span><br><span class="hljs-title class_">NaN</span> * <span class="hljs-number">32</span> <span class="hljs-comment">// NaN</span><br><span class="hljs-title class_">NaN</span> / <span class="hljs-number">32</span> <span class="hljs-comment">// NaN</span><br><span class="hljs-title class_">Infinity</span> &gt; <span class="hljs-title class_">NaN</span> <span class="hljs-comment">// false</span><br>-<span class="hljs-title class_">Infinity</span> &gt; <span class="hljs-title class_">NaN</span> <span class="hljs-comment">// false</span><br><span class="hljs-title class_">Infinity</span> &lt; <span class="hljs-title class_">NaN</span> <span class="hljs-comment">// false</span><br>-<span class="hljs-title class_">Infinity</span> &lt; <span class="hljs-title class_">NaN</span> <span class="hljs-comment">// false</span><br><span class="hljs-comment">//Infinity与NaN比较，总是返回false。</span><br></code></pre></td></tr></table></figure></blockquote>          </div><h3 id="2-5-与数值相关的全局方法">2.5 与数值相关的全局方法</h3><p>JavaScript预定义了全局常量<code>Infinity</code>和<code>NaN</code>以对应<code>正无穷</code>和<code>非数值</code>。这些值也可以通过Number对象的属性获取：</p><h4 id="big-parseInt-big"><big><code>parseInt()</code></big></h4><hr><p><strong>1、基本用法：</strong></p><blockquote><p><strong>parseInt方法用于将字符串转为整数。</strong></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;123&#x27;</span>) <span class="hljs-comment">//123</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>如果字符串头部有空格，空格会被自动去除。</strong></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;    123&#x27;</span>) <span class="hljs-comment">//123</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>如果parseInt的参数不是字符串，则会先转为字符串再转换。</strong></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">1.23</span>) <span class="hljs-comment">//1</span><br><span class="hljs-comment">// &lt;==&gt; 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1.23&#x27;</span>) <span class="hljs-comment">//1</span><br></code></pre></td></tr></table></figure><p><big><span class="label label-warning">字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。</span></big></p><blockquote><p>1、parseInt的参数都是字符串，结果只返回字符串头部可以转为数字的部分。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;8a&#x27;</span>) <span class="hljs-comment">// 8</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;12**&#x27;</span>) <span class="hljs-comment">// 12</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;12.34&#x27;</span>) <span class="hljs-comment">// 12</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;15e2&#x27;</span>) <span class="hljs-comment">// 15</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;15px&#x27;</span>) <span class="hljs-comment">// 15</span><br></code></pre></td></tr></table></figure><p>2、如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;abc&#x27;</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;.3&#x27;</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;+&#x27;</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;+1&#x27;</span>) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure></blockquote><p><big><span class="label label-warning">parseInt的返回值只有两种可能，要么是一个十进制整数，要么是NaN。</span></big></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//如果字符串以0x或0X开头，parseInt会将其按照十六进制数解析。</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;0x10&#x27;</span>) <span class="hljs-comment">// 16</span><br><span class="hljs-comment">//如果字符串以0开头，将其按照10进制解析。</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;011&#x27;</span>) <span class="hljs-comment">// 11</span><br><span class="hljs-comment">//对于那些会自动转为科学计数法的数字，parseInt会将科学计数法的表示方法视为字符串，</span><br><span class="hljs-comment">//因此导致一些奇怪的结果。</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">1000000000000000000000.5</span>) <span class="hljs-comment">// 1,小数点前多于21位</span><br><span class="hljs-comment">// &lt;==&gt; 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1e+21&#x27;</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">0.0000008</span>) <span class="hljs-comment">// 8,小数点后多余5个0</span><br><span class="hljs-comment">// &lt;==&gt; 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;8e-7&#x27;</span>) <span class="hljs-comment">// 8</span><br></code></pre></td></tr></table></figure><p><strong>2、进制转换：</strong><br>parseInt方法还可以接受第二个参数（<code>2到36</code>之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，parseInt的第二个参数为10，即默认是十进制转十进制。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1000&#x27;</span>) <span class="hljs-comment">// 1000</span><br><span class="hljs-comment">// &lt;==&gt; 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1000&#x27;</span>, <span class="hljs-number">10</span>) <span class="hljs-comment">// 1000</span><br><br><span class="hljs-built_in">parseInt</span>方法可带参数进行进制的转换<br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1000&#x27;</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 二进制1000等于十进制的8</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1000&#x27;</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// 六进制1000等于十进制的216</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1000&#x27;</span>, <span class="hljs-number">8</span>) <span class="hljs-comment">// 八进制1000等于十进制的512</span><br><br>如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在<span class="hljs-number">2</span>到<span class="hljs-number">36</span>之间，才能得到有意义的结果，<br>超出这个范围，则返回<span class="hljs-title class_">NaN</span>。如果第二个参数是<span class="hljs-number">0</span>、<span class="hljs-literal">undefined</span>和<span class="hljs-literal">null</span>，则直接忽略。<br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-number">37</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// 10</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-literal">null</span>) <span class="hljs-comment">// 10</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// 10</span><br>  <br>如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。<br>如果最高位无法转换，则直接返回<span class="hljs-title class_">NaN</span>。<br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1546&#x27;</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;546&#x27;</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><p>如果parseInt的第一个参数不是字符串，会被先转为字符串。这会导致一些令人意外的结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">0x11</span>, <span class="hljs-number">36</span>) <span class="hljs-comment">// 43</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">0x11</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-title class_">String</span>(<span class="hljs-number">0x11</span>), <span class="hljs-number">36</span>)<br><span class="hljs-built_in">parseInt</span>(<span class="hljs-title class_">String</span>(<span class="hljs-number">0x11</span>), <span class="hljs-number">2</span>)<br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;17&#x27;</span>, <span class="hljs-number">36</span>) <span class="hljs-comment">//43</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;17&#x27;</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment">//1</span><br></code></pre></td></tr></table></figure><p>上面代码中，十六进制的0x11会被先转为十进制的17，再转为字符串。然后，再用36进制或二进制解读字符串17，最后返回结果43和1。</p><p>这种处理方式，对于八进制的前缀0，尤其需要注意。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">011</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// NaN</span><br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-title class_">String</span>(<span class="hljs-number">011</span>), <span class="hljs-number">2</span>)<br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-title class_">String</span>(<span class="hljs-number">9</span>), <span class="hljs-number">2</span>) <span class="hljs-comment">//NaN</span><br></code></pre></td></tr></table></figure><p>上面代码中，第一行的011会被先转为字符串9，因为9不是二进制的有效字符，所以返回NaN。如果直接计算parseInt(‘011’, 2)，011则是会被当作二进制处理，返回3。</p><p>JavaScript 不再允许将带有前缀0的数字视为八进制数，而是要求忽略这个0。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定。</p><h4 id="big-parseFloat-big"><big><code>parseFloat()</code></big></h4><hr><p><code>parseFloat</code>方法用于将一个字符串转为浮点数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;1.23&#x27;</span>) <span class="hljs-comment">//1.23</span><br></code></pre></td></tr></table></figure><p><em>1. 如果字符串符合科学计数法，则会进行相应的转换。</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;123e-2&#x27;</span>) <span class="hljs-comment">//1.23</span><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;0.0123e+2&#x27;</span>) <span class="hljs-comment">//1.23</span><br></code></pre></td></tr></table></figure><p><em>2. 如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;3.14more non-digit characters&#x27;</span>) <span class="hljs-comment">// 3.14</span><br></code></pre></td></tr></table></figure><p><em>3. parseFloat方法会自动过滤字符串前导的空格。</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;\t\v\r12.34\n &#x27;</span>) <span class="hljs-comment">// 12.34</span><br><span class="hljs-comment">// \&#x27; Single quote (&#x27;)</span><br><span class="hljs-comment">// \&quot; Double quote (&quot;)</span><br><span class="hljs-comment">// \a ASCII Bell (BEL)</span><br><span class="hljs-comment">// \b ASCII Backspace (BS)</span><br><span class="hljs-comment">// \f ASCII Formfeed (FF)</span><br><span class="hljs-comment">// \n ASCII Linefeed (LF)</span><br><span class="hljs-comment">// \N&#123;name&#125; Character named name in the Unicode database (Unicode only)</span><br><span class="hljs-comment">// \r ASCII Carriage Return (CR)</span><br><span class="hljs-comment">// \t ASCII Horizontal Tab (TAB)</span><br><span class="hljs-comment">// \uxxxx Character with 16-bit hex value xxxx (Unicode only) (1) </span><br><span class="hljs-comment">// \Uxxxxxxxx Character with 32-bit hex value xxxxxxxx (Unicode only) (2)</span><br><span class="hljs-comment">// \v ASCII Vertical Tab (VT)</span><br></code></pre></td></tr></table></figure><p><em>4. 如果参数不是字符串，则会先转为字符串再转换。</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseFloat</span>([<span class="hljs-number">1.23</span>]) <span class="hljs-comment">// 1.23</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-title class_">String</span>([<span class="hljs-number">1.23</span>])) <span class="hljs-comment">// 1.23</span><br></code></pre></td></tr></table></figure><p><em>5. 如果字符串的第一个字符不能转化为浮点数，则返回NaN。</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseFloat</span>([]) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;FF2&#x27;</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// NaN</span><br><br>上面代码中，尤其值得注意，<span class="hljs-built_in">parseFloat</span>会将空字符串转为<span class="hljs-title class_">NaN</span>。<br></code></pre></td></tr></table></figure><p>这些特点使得parseFloat的转换结果不同于Number函数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseFloat</span>(<span class="hljs-literal">true</span>)  <span class="hljs-comment">// NaN</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// 1</span><br><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// 0</span><br><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// 0</span><br><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;123.45#&#x27;</span>) <span class="hljs-comment">// 123.45</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-string">&#x27;123.45#&#x27;</span>) <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><h4 id="big-isNaN-big"><big><code>isNaN()</code></big></h4><hr><p><code>isNaN</code>方法可以用来判断一个值是否为<code>NaN</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">NaN</span>) <span class="hljs-comment">//true</span><br><span class="hljs-built_in">isNaN</span>(<span class="hljs-number">123</span>) <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><p><code>isNaN</code>只对<code>数值</code>有效，如果传入其他值，会被先转成数值。比如，<u>传入字符串的时候，字符串会被先转成NaN，所以最后返回true</u>，这一点要特别引起注意。也就是说，<strong>isNaN为true的值，有可能不是NaN，而是一个字符串</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>) <span class="hljs-comment">// true</span><br><span class="hljs-comment">// 相当于</span><br><span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">Number</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>)) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>出于同样的原因，对于对象和数组，isNaN也返回true。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">isNaN</span>(&#123;&#125;) <span class="hljs-comment">// true</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">Number</span>(&#123;&#125;)) <span class="hljs-comment">// true</span><br><br><span class="hljs-built_in">isNaN</span>([<span class="hljs-string">&#x27;xzy&#x27;</span>]) <span class="hljs-comment">// true</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">Number</span>([<span class="hljs-string">&#x27;xzy&#x27;</span>])) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>但是，对于空数组和只有一个数值成员的数组，isNaN返回false。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">isNaN</span>([]) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isNaN</span>([<span class="hljs-number">123</span>]) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isNaN</span>([<span class="hljs-string">&#x27;123&#x27;</span>]) <span class="hljs-comment">// false</span><br>上面代码之所以返回<span class="hljs-literal">false</span>，原因是<span class="hljs-string">`Number()`</span>把空数组、空格、以及<span class="hljs-title class_">NUll</span>按照<span class="hljs-number">0</span>来处理 <br></code></pre></td></tr></table></figure><p>因此，使用isNaN之前，最好判断一下数据类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myIsNaN</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;number&#x27;</span> &amp;&amp; <span class="hljs-built_in">isNaN</span>(value);<br>  <span class="hljs-comment">//结果为return true;函数才返回结果。等同于</span><br>  <span class="hljs-comment">// [typeof value === &#x27;number&#x27;] &amp;&amp; [isNaN(value)] 结果都为true,函数才返回结果。</span><br>  <span class="hljs-comment">//即 value为数值类型并且 isNan(value)结果为true，两个条件都需达成</span><br>&#125;<br></code></pre></td></tr></table></figure><p>判断NaN更可靠的方法是，利用<code>NaN</code>为<em>唯一</em>不等于自身的值的这个特点，进行判断。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myIsNaN</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-keyword">return</span> value !== value;<br>  <span class="hljs-comment">// x != x,有且仅当x为NaN时成立。</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="big-isFinite-big"><big><code>isFinite()</code></big></h4><hr><p><code>isFinite</code>方法返回一个布尔值，表示某个值是否为正常的数值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">isFinite</span>(<span class="hljs-title class_">Infinity</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isFinite</span>(-<span class="hljs-title class_">Infinity</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isFinite</span>(<span class="hljs-title class_">NaN</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isFinite</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isFinite</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">isFinite</span>(-<span class="hljs-number">1</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>除了<code>Infinity</code>、<code>-Infinity</code>、<code>NaN</code>和<code>undefined</code>这几个值会返回false，isFinite对于其他的数值都会返回true。</p><h3 id="2-6-big-Number对象的属性-big">2.6 <big>Number对象的属性</big></h3><hr><table><thead><tr><th>全局对象</th><th>结果释义</th><th>对应Number属性</th><th>结果释义</th></tr></thead><tbody><tr><td>Infinity</td><td>因为太大而无法表示的正数</td><td>Number.POSITIVE_INFINITY</td><td>相同</td></tr><tr><td>-Infinity</td><td>因为太大而无法表示的负数</td><td>Number.NAGATIVE_INFINITY</td><td>相同</td></tr><tr><td>1/0</td><td>Infinity</td><td>Number.MAX_VALUE *2</td><td>Infinity;溢出</td></tr><tr><td>-1/0</td><td>-Infinity</td><td>-Number.MAX_VALUE *2</td><td>-Infinity;</td></tr><tr><td>NaN</td><td>非数值</td><td>Number.NaN</td><td>非数值；与全局写法不同而已</td></tr><tr><td>0/0</td><td>NaN</td><td>Infinity/Infinity</td><td>NaN</td></tr><tr><td>Number.MIN_VALUE / 2</td><td>0;下溢出</td><td>-Number.MIN_VALUE/2</td><td>-0</td></tr><tr><td>-1/Infinity</td><td>-0</td><td>-0 /Infinity</td><td>-0</td></tr></tbody></table><blockquote><p><em>ES6新增Number属性</em></p></blockquote><table><thead><tr><th>ES6定义的属性</th><th>对应全局函数</th><th>属性释义</th></tr></thead><tbody><tr><td>Number.parseInt()</td><td>parseInt()</td><td>一致</td></tr><tr><td>Number.parseFloat()</td><td>parseFloat()</td><td>一致</td></tr><tr><td>Number.isNan()</td><td>isNaN()</td><td>判断是不是NaN,在参数是NaN时，或者在参数是无法转换为数值的非数值时返回true</td></tr><tr><td>Number.isFinite()</td><td>isFinite()</td><td>Number.isFinite()在参数不是NaN、Infinity或-Infinity时返回true。<br>全局isFinite()函数在参数是有限数或者可以转换为有限数时返回true</td></tr><tr><td>Number.isInteger()</td><td></td><td>用来判断给定的参数是否为整数。<br>注意 NaN 和正负 Infinity 不是整数</td></tr><tr><td>Number.isSafeInteger()</td><td></td><td>用来判断传入的参数值是否是一个“安全整数”,安全整数范围为 -(2^53 - 1) 到 2^53 - 1 之间的整数，包含 -(2^53 - 1) 和 2^53 - 1</td></tr><tr><td>Number.MIN_SAFE_INTEGER</td><td></td><td>-(2^53 - 1)</td></tr><tr><td>Number.MAX_SAFE_INTEGER</td><td></td><td>(2^53 - 1)</td></tr><tr><td>Number.EPSILON</td><td></td><td>表示 1 与Number可表示的大于 1 的最小的浮点数之间的差值<br>(可理解为两个数值之间最小的误差值，例如，0.1+0.2!=0.3,但是，如果0.1+0.2-0.3 &lt; <code>Number.EPSILON</code>的话，即可证明0.1+0.2===0.3)；<br>不必创建Number对象可直接使用。<br>EPSILON 属性的值接近于 2.2204460492503130808472633361816E-16，或者 2^-52；</td></tr></tbody></table><h3 id="2-7-通过BigInt表示任意精度整数">2.7 通过BigInt表示任意精度整数</h3><h3 id="2-8-日期和时间的数值表示形式">2.8 日期和时间的数值表示形式</h3><h2 id="注释："><em><strong>注释：</strong></em></h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.silentblue.top/2022/06/10/%E6%B5%85%E8%B0%88IEEE754%E6%A0%87%E5%87%86%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AF%AF%E5%B7%AE%E6%88%90%E5%9B%A0/">https://blog.silentblue.top/2022/06/10/浅谈IEEE754标准的浮点数误差成因/</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
      <category>学习笔记</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据类型</tag>
      
      <tag>数值</tag>
      
      <tag>文本字符串</tag>
      
      <tag>布尔值</tag>
      
      <tag>boolean</tag>
      
      <tag>undefined</tag>
      
      <tag>symbol</tag>
      
      <tag>对象</tag>
      
      <tag>math</tag>
      
      <tag>数学</tag>
      
      <tag>算数</tag>
      
      <tag>object</tag>
      
      <tag>array</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript中相等和严格相等运算符的简要比较</title>
    <link href="/2022/06/12/Javascript%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%B8%A5%E6%A0%BC%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/"/>
    <url>/2022/06/12/Javascript%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%B8%A5%E6%A0%BC%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1-全等运算符">1. 全等运算符 ===</h2><p>首先，全等操作符比较两个值是否相等，两个被比较的值在比较前都不进行隐式转换。如果两个被比较的值具有不同的类型，这两个值是不全等的；其次，如果两个被比较的值类型相同，值也相同，并且都不是 number 类型时，两个值全等；最后，如果两个值都是 number 类型，当两个都不是 NaN，并且数值相同，或是两个值分别为 +0 和 -0 时，两个值被认为是全等的。</p><blockquote><p>注意，在全等运算中，NaN 与其他任何值相比,结果都是 false。</p></blockquote><h3 id="1-1-基本规则">1.1 基本规则</h3><div class="note note-info">            <p><strong>全等和不全等操作符遵循以下基本规则：</strong></p><ol><li>如果两个操作数有不同的类型，它们不是严格相等的；<br><code>1 === &quot;1&quot; // false, undefined === null // false</code></li><li>如果两个操作数都为 null，则它们是严格相等的；<br><code>null === null // true</code></li><li>如果两个操作数都为 undefined，它们是严格相等的；<br><code>undefined === undefined // true</code></li><li>如果一个或两个操作数都是 NaN，它们就不是严格相等的；<br><code>NaN === NaN // false</code></li><li>如果两个操作数都为 true 或都为 false，它们是严格相等的；<br><code>true === true //true, false === false; //true</code></li><li>如果两个操作数都是 number 类型并且具有相同的值，则它们是严格相等的；<br><code>0 === 0 // true</code></li><li>如果两个操作数都是 string 类型并且具有相同的值，则它们是严格相等的；<br><code>&quot;a&quot; === &quot;a&quot; //true</code></li><li>如果两个操作数都引用相同的对象或函数，则它们是严格相等的；<br><code>var firstObject = {},  secondObject = firstObject;</code><br><code>secondObject['name'] = 'Neo';</code><br><code>secondObject === firstObject // true</code></li><li>以上所有其他情况下操作数都不是严格相等的。<br><code>[] === [] //false</code><br><code>[]可以理解为new Array()，相当于声明了一个新的空数组，程序会自动在堆中为其开辟一块内存空间，[]和[]生成的内存空间不是同一块，所以自然不相等。</code></li></ol>          </div><h2 id="2-对象与原始值的转换">2. 对象与原始值的转换</h2><div class="note note-warning">            <p>待补充</p>          </div><h2 id="3-相等运算符">3. 相等运算符 ==</h2><p>如果两个操作数不是同一类型，那么相等运算符会尝试一些类型转换，然后进行比较。</p><h3 id="3-1-基本规则">3.1 基本规则</h3><div class="note note-info">            <blockquote><p>如果操作数具有相同的类型，请测试它们是否严格相等。 如果它们不严格相等，则它们不相等，否则相等。</p></blockquote><p><strong>如果操作数有不同的类型：</strong></p><ol><li>如果一个操作数为 null 而另一个 undefined，则它们相等;</li><li>如果一个值是数字，另一个是字符串，先将字符串转换为数字，然后使用转换后的值比较;</li><li>如果一个操作数是布尔值，则将 true 转换为 1，将 false 转换为 0，然后使用转换后的值比较;</li><li>如果一个操作数是一个对象，而另一个操作数是一个数字或字符串，则将该对象转换为原始值，再使用转换后的值比较;</li></ol><blockquote><p>在以上的其他情况下，操作数都不相等;</p></blockquote>          </div><h2 id="4-函数和方法">4. 函数和方法</h2><h3 id="4-1-switch…case">4.1 switch…case</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">switch</span> (expression) &#123;<br>   <span class="hljs-keyword">case</span> <span class="hljs-attr">value1</span>:<br>    <span class="hljs-keyword">break</span>;<br>   <span class="hljs-keyword">case</span> <span class="hljs-attr">value2</span>:<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-attr">default</span>:<br>    <span class="hljs-title function_">caseDidNotHappens</span>();<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p><strong>描述：</strong><br>一个 switch 语句首先会计算其 expression 。然后，它将从第一个 case 子句开始直到寻找到一个其表达式值与所输入的 expression 的值所相等的子句（使用 <code>严格运算符 </code>===）并将控制权转给该子句，执行相关语句。（如果多个 case 与提供的值匹配，则选择匹配的第一个 case，即使这些 case 彼此间并不相等。）</p><p>如果没有 case 子句相匹配，程序则会寻找那个可选的 default 子句，如果找到了，将控制权交给它，执行相关语句。若没有 default 子句，程序将继续执行直到 switch 结束。按照惯例，default 子句是最后一个子句，不过也不需要这样做。</p><p>可选的 break 语句确保程序立即从相关的 case 子句中跳出 switch 并接着执行 switch 之后的语句。若 break 被省略，程序会继续执行 switch 语句中的下一条语句。</p>          </div><h3 id="4-2-indexOf">4.2 indexOf()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">arr.<span class="hljs-title function_">indexOf</span>(searchElement[, fromIndex])<br></code></pre></td></tr></table></figure><blockquote><p>该方法将从头到尾地检索字符串 arr，看它是否含有子串 searchElement。开始检索的位置在字符串的 fromIndex 处或字符串的开头（没有指定 fromIndex 时）。如果找到一个 searchElement，则返回 searchElement 的第一次出现的位置。arr 中的字符位置是从 0 开始的。</p></blockquote><div class="note note-info">            <p><strong>提示和注释：</strong></p><p><em><strong>注释：</strong></em><br>indexOf() 方法对大小写敏感。</p><p>fromIndex 开始查找的位置。<br>如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回 -1。<br>如果参数中提供的索引值是一个负值，则将其作为数组末尾的一个抵消，即 -1 表示从最后一个元素开始查找，-2 表示从倒数第二个元素开始查找 ，以此类推。</p><p><em><strong>描述：</strong></em><br>indexOf 使用<code>严格相等运算符</code> 进行判断 searchElement 与数组中包含的元素之间的关系。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
      <category>学习笔记</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>===</tag>
      
      <tag>严格相等运算符</tag>
      
      <tag>==</tag>
      
      <tag>相等运算符</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈IEEE 754标准的浮点数误差成因</title>
    <link href="/2022/06/10/%E6%B5%85%E8%B0%88IEEE754%E6%A0%87%E5%87%86%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AF%AF%E5%B7%AE%E6%88%90%E5%9B%A0/"/>
    <url>/2022/06/10/%E6%B5%85%E8%B0%88IEEE754%E6%A0%87%E5%87%86%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AF%AF%E5%B7%AE%E6%88%90%E5%9B%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-IEEE-754标准的产生">1. IEEE 754标准的产生</h2><p>20 世纪 80 年代（没有制定 IEEE 754 标准）之前，业界还没有一个统一的浮点数标准。相反，很多计算机制造商根据自己的需要来设计自己的浮点数表示规则，以及浮点数的执行运算细节。另外，他们常常并不太关注运算的精确性，而把实现的速度和简易性看得比数字的精确性更重要，而这就给代码的可移植性造成了重大的障碍。</p><p>直到 1976 年，Intel 公司打算为其 8086 微处理器引进一种浮点数协处理器时，意识到作为芯片设计者的电子工程师和固体物理学家也许并不能通过数值分析来选择最合理的浮点数二进制格式。于是，他们邀请加州大学伯克利分校的 William Kahan 教授（当时最优秀的数值分析家）来为 8087 浮点处理器（FPU）设计浮点数格式。而这时，William Kahan 教授又找来两个专家协助他，于是就有了 KCS 组合（Kahn、Coonan和Stone），并共同完成了 Intel 公司的浮点数格式设计。</p><p>由于 Intel 公司的 KCS 浮点数格式完成得如此出色，以致 IEEE（Institute of Electrical and Electronics Engineers，电子电气工程师协会）决定采用一个非常接近 KCS 的方案作为 IEEE 的标准浮点格式。于是，IEEE 于 1985 年制订了二进制浮点运算标准 IEEE 754（IEEE Standard for Binary Floating-Point Arithmetic，ANSI/IEEE Std 754-1985），该标准限定指数的底为 2，并于同年被美国引用为 ANSI 标准。目前，几乎所有的计算机都支持 IEEE 754 标准，它大大地改善了科学应用程序的可移植性。</p><p>考虑到 IBM System/370 的影响，IEEE 于 1987 年推出了与底数无关的二进制浮点运算标准 IEEE 854，并于同年被美国引用为 ANSI 标准。1989 年，国际标准组织 IEC 批准 IEEE 754/854 为国际标准 IEC 559：1989。后来经修订后，标准号改为 IEC 60559。现在，几乎所有的浮点处理器完全或基本支持 IEC 60559。同时，C99 的浮点运算也支持 IEC 60559。</p><h2 id="2-标准浮点格式">2. 标准浮点格式</h2><p>IEEE 754标准准确地定义了单精度和双精度浮点格式，并为这两种基本格式分别定义了扩展格式，如下所示：</p><blockquote><ul><li>单精度浮点格式（32 位）。</li><li>双精度浮点格式（64 位）。</li><li>扩展单精度浮点格式（≥43 位，不常用）。</li><li>扩展双精度浮点格式（≥79 位，一般情况下，Intel x86 结构的计算机采用的是 80 位，而 SPARC 结构的计算机采用的是 128 位）。</li></ul></blockquote><p>其中，只有 32 位单精度浮点数是本标准强烈要求支持的，其他都是可选部分。本文主要针对单精度浮点与双精度浮点的存储格式做一些简要的阐述。</p><h3 id="2-1-什么是浮点误差">2.1 什么是浮点误差</h3><p>很多人在写代码时中都曾经遇到过所谓的浮点误差，以js为例来看0.1+0.2结果是什么：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;浮点误差：&quot;</span> + <span class="hljs-string">&quot;\n&quot;</span> + <span class="hljs-string">&quot;0.1+0.2=&quot;</span> + <span class="hljs-string">&quot;\n&quot;</span> + (<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>));<br><span class="hljs-comment">//浮点误差：</span><br><span class="hljs-comment">//0.1+0.2=</span><br><span class="hljs-comment">//0.30000000000000004</span><br></code></pre></td></tr></table></figure><p>正常情况下应该是0.1+0.2=0.3，但为什么运算结果却不是呢，这并不是什么bug，也并不是程序设计有问题，这个原因与浮点数的存储原理有关。在开始了解浮点数的存储原理前，需要先知道js中数值是以何种形式存储的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs info">JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。<br>所以，1与1.0是相同的，是同一个数。<br><br>1 === 1.0 // true<br><br>这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。<br>容易造成混淆的是，某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，<br>然后再进行运算。<br><br>由于浮点数不是精确的值，所以js中涉及小数的比较和运算要特别小心。<br></code></pre></td></tr></table></figure><h3 id="2-2-计算机中是如何存储整数的">2.2 计算机中是如何存储整数的</h3><p>在了解为什么会产生浮点误差前，我们先了解一下计算机是如何用0和1来表示一个整数的。我们知道计算机主要是采用二进制计算和存储数据的，我们假设一个<code>32bit</code>的无符号整数（unsigned integer），那么就是说它有32个位置来存放0或1，那么它的值的范围就是0~2<sup>32</sup>-1，即0~4294967295，也就是说它可以精确的表达出0~4294967295之间任意整数而不会有误差。</p><p>同时，我们可以看得出虽然0~2<sup>32</sup>有很多整数，但个数毕竟是有限的，但是浮点数就不同了，它可以有例如，2.1，2.11，2.111…等等无数个浮点数。那么该如何把这些无限的浮点数塞进有限的<code>32bit</code>的空间里呢，在IEEE 754标准诞生前，各个CPU厂家发明了各种浮点数的表示方法，后来则是统一遵循这个标准进行设计。</p><h3 id="2-3-浮点数格式的正规化">2.3 浮点数格式的正规化</h3><p>浮点数在存储之前必需先进行符合IEEE 754的格式的正规化操作，即由一个有效数字乘以2的整数次幂得到,类似于十进制的科学计数法，下面举例说明：</p><blockquote><p>浮点数5.5如何进行格式正规化：<br>5.5=5+0.5<br>转化为二进制：<br>2<sup>2</sup>+2<sup>1</sup>+2<sup>-1</sup> 即 101.1<br>格式正规化：<br>1.011×2<sup>2</sup></p></blockquote><h3 id="2-4-十进制与二进制的转化">2.4 十进制与二进制的转化</h3><p>十进制数值转化为二进制方法之一：整数部分为留余数，倒排序；小数部分为乘以2，一直到全部转化整数为止，正排序。也可使用<a href="https://tool.oschina.net/hexconvert">在线进制转换工具</a></p><blockquote><p>十进制8.125转化为二进制：<br>整数部分：<br>8÷2=4 余数 <code>0</code>；4÷2=2 余数 <code>0</code>；2÷2=1 余数 <code>0</code>；最后剩余 <code>1</code>；倒排序二进制表示为 <code>1000</code><br>小数部分：<br>0.125×2=0.25 整数部分 <code>0</code>；0.25×2=0.5 整数部分 <code>0</code>；0.5×2=1 整数部分 <code>1</code>；正序二进制表示为 <code>001</code><br>因此十进制<code>8.125</code>转化为二进制为 <code>1000.001</code></p></blockquote><h3 id="2-5-浮点数的表示法">2.5 浮点数的表示法</h3><p>一个浮点数分为三个部分，分别是符号位（sign bit），指数偏移值(exponent bias)，分数值(fraction)。浮点数的值(value)=符号位（sign bit）×指数偏移值(exponent bias)×有效数(fraction)。</p><blockquote><p>符号(S) :用來表示正/负(0/1)。<br>指数(E) :浮点数正规化后的次方，单精度的指数部分采用超127格式，即将原本的次方数加上127，因为次方数有可能是负的，加上计算机要表示负号时，必须拿一个位元来表示，所以就将-128~+127改为0~255，所以基准点就从0变成127。双精度的指数部分是−1022～+1023加上1023，指数值的大小从1～2046（0（2进位全为0）和2047（2进位全为1）是特殊值）。浮点小数计算时，指数值减去偏正值将是实际的指数大小。<br>有效数(F) :正规化后小数点之后的值。</p></blockquote><h4 id="单精度浮点数-float">单精度浮点数(float)</h4><p><img src="1-1.jpg" alt="单精度浮点数表示法"><br>sign：最左侧<code>1bit</code> 代表正负号，正数的话<code>sign</code>就为<code>0</code>，反之则是 <code>1</code><br>exponent：中间的<code>8bit</code>代表正规化后的次方数，采用的是<code>超127格式</code>，也就是<code>次方数</code>还要再加上<code>127</code><br>fraction：最右侧的<code>23bit</code> 放的是小数部分，以<code>1.0001</code>来说就是去掉<code>1.</code>之后的<code>0001</code></p><p>我们以<code>8.125</code>为例，表示成IEEE 754标准的<code>32bit</code>格式：</p><blockquote><p>正规化：8.125=+1.000001×2<sup>3</sup></p></blockquote><table><thead><tr><th>Sign</th><th>Exponent</th><th>Fraction</th></tr></thead><tbody><tr><td>0 (+)</td><td>1000 0010 (3+127=130)</td><td>0000 0100 0000 0000 0000 000</td></tr></tbody></table><blockquote><p>二进制表示：0100 0001 0000 0010 0000 00000 0000 0000</p></blockquote><p>0.1 + 0.2 != 0.3的原因就在于0.1、0.2和0.3分别用二进制表示时，均无法转化成2的次方数相加，最后产生不同误差。</p><p>有兴趣可以到<a href="https://www.h-schmidt.net/FloatConverter/IEEE754.html">IEEE-754 Floating Point Converter</a>官网测试。</p><h4 id="双精度浮点数-double">双精度浮点数(double)</h4><p>为了让误差更小，<code>IEEE 754</code>也定义了如何用<code>64bit</code>来表示浮点数，跟<code>32bit</code>比起来<code>fraction</code>部分大了超过两倍，从<code>23bit</code>变成<code>52bit</code>，所以精准度自然提高许多。</p><p><img src="1-2.jpg" alt="双精度浮点数表示法"><br>sign：最左侧<code>1bit</code> 代表正负号，正数的话<code>sign</code>就为<code>0</code>，反之则是 <code>1</code><br>exponent：中间的<code>1bit</code>代表正规化后的次方数，采用的是<code>超1023格式</code>，也就是<code>次方数</code>还要再加上<code>1023</code><br>fraction：最右侧的<code>52bit</code> 放的是小数部分，以<code>1.0001</code>来说就是去掉<code>1.</code>之后的<code>0001</code></p><p><img src="2.jpg" alt="单双精度浮点数的对比"></p><h3 id="2-6-如何解决浮点数误差">2.6 如何解决浮点数误差</h3><p>1、设定一个最大允许误差值（EPSILON）<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON">例如ES6中内置的Number.EPSILON</a></p><blockquote><p>例如把 0.1 + 0.2 == 0.3改写成 0.1 + 0.2 — 0.3 &lt;= epsilon</p></blockquote><p>2、完全使用十进制进行计算，但不建议大规模使用，因为十进制计算是组件模拟出来的，CPU计算时仍会转化为二进制，会拖慢运算速度。</p><!-- $$E=mc^2$$ --><!-- ```mermaid --><!-- classDiagramClass01 <|-- AveryLongClass : CoolClass03 *-- Class04Class05 o-- Class06Class07 .. Class08Class09 --|> C2 : Where am i?Class09 --* C3Class09 --|> Class07Class07 : equals()Class07 : Object[] elementDataClass01 : size()Class01 : int chimpClass01 : int gorillaClass08 <--|> C2: Cool label --><!-- ``` --><!-- <a class="btn" href="url" title="title">text</a> -->]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
      <category>学习笔记</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IEEE754</tag>
      
      <tag>浮点数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>条件语句和循环语句</title>
    <link href="/2022/06/07/%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"/>
    <url>/2022/06/07/%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="1-条件语句">1. 条件语句</h2><p>JavaScript提供 <a href="">if</a> 结构和 <a href="">switch</a> 结构，用以完成条件判断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs parsing">即只有满足预设的条件，才会执行相应的语句。<br></code></pre></td></tr></table></figure><h3 id="1-1-if-结构">1.1 <a href="">if</a> 结构</h3><p>if 结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句。所谓布尔值，指的是 JavaScript 的两个特殊值，true表示“真”，false表示“伪”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (布尔值)<br>  语句;<br><br><span class="hljs-comment">// 或者</span><br><span class="hljs-keyword">if</span> (布尔值) 语句;<br></code></pre></td></tr></table></figure><p>上面这种写法要求条件表达式后面只能有一个语句。如果想执行多个语句，必须在if的条件判断之后，加上大括号，表示代码块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (布尔值) &#123;<br>  语句一;<br>  语句二;<br>  ...<br>  语句N;<br>&#125;<br></code></pre></td></tr></table></figure><p>建议总是在if语句中使用大括号，因为这样方便插入语句。</p><h3 id="1-2-if…else-结构">1.2 <a href="">if…else</a> 结构</h3><p>if代码块后面，还可以跟一个else代码块，表示不满足条件时，所要执行的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (布尔值) &#123;<br>  <span class="hljs-comment">// 满足条件时，执行的语句</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 不满足条件时，执行的语句</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对同一个变量进行多次判断时，多个if…else语句可以连写在一起。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (条件一) &#123;<br>  <span class="hljs-comment">// 满足条件一执行</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (条件二) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (条件三) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>else代码块总是与离自己最近的那个if语句配对。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> m = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> n = <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">if</span> (m !== <span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> (n === <span class="hljs-number">2</span>) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;world&#x27;</span>);<br></code></pre></td></tr></table></figure><p>上面代码不会有任何输出，else代码块不会得到执行，因为它跟着的是最近的那个if语句，相当于下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (m !== <span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;world&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果想让else代码块跟随最上面的那个if语句，就要改变大括号的位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (m !== <span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>  &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;world&#x27;</span>);<br>&#125;<br><span class="hljs-comment">// world</span><br></code></pre></td></tr></table></figure><h3 id="1-3-switch-结构">1.3 <a href="">switch</a> 结构</h3><p>多个<a href="">if…else</a>连在一起使用的时候，可以转为使用更方便的<a href="">switch</a>结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">switch</span> (x) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;x 等于1&#x27;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;x 等于2&#x27;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-attr">default</span>:<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;x 等于其他值&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码根据变量x的值，选择执行相应的case。如果所有case都不符合，则执行最后的default部分。需要注意的是，每个case代码块内部的break语句不能少，否则会接下去执行下一个case代码块，而不是跳出switch结构。</p><p>switch语句部分和case语句部分，都可以使用表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">switch</span> (<span class="hljs-number">1</span> + <span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span> + <span class="hljs-number">2</span>:<br>    <span class="hljs-title function_">fn</span>();<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-attr">default</span>:<br>    <span class="hljs-title function_">neverHappens</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>switch表达式与case表示式比较运行结果时，采用的是 <strong>严格相等运算符（===）</strong>，而不是 <strong>相等运算符（==）</strong>，这意味着比较时 <em>不会发生</em> 类型转换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">switch</span> (x) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-attr">true</span>:<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;x 发生类型转换&#x27;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-attr">default</span>:<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;x 没有发生类型转换&#x27;</span>);<br>&#125;<br><span class="hljs-comment">// x 没有发生类型转换</span><br></code></pre></td></tr></table></figure><p>上面代码中，由于变量x <strong>没有发生类型转换</strong>，所以不会执行case true的情况。这表明，switch语句内部采用的是 <strong>严格相等运算符</strong>。</p><h3 id="1-4-三元运算符-结构">1.4 三元运算符<a href="">? :</a> 结构</h3><p>JavaScript 还有一个三元运算符（即该运算符需要三个运算子）<a href="">? :</a>，也可以用于逻辑判断。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(条件) ? 表达式<span class="hljs-number">1</span> : 表达式<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>上面代码中，如果“条件”为true，则返回“表达式1”的值，否则返回“表达式2”的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> even = (n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><p>上面代码中，如果n可以被2整除，则even等于true，否则等于false。它等同于下面的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> even;<br><span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) &#123;<br>  even = <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  even = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个三元运算符可以被视为 <a href="">if…else…</a> 的简写形式，因此可以用于多种场合。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myVar;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>  myVar ?<br>  <span class="hljs-string">&#x27;myVar has a value&#x27;</span> :<br>  <span class="hljs-string">&#x27;myVar does not have a value&#x27;</span><br>)<br><span class="hljs-comment">// myVar does not have a value</span><br><br><span class="hljs-keyword">var</span> msg = <span class="hljs-string">&#x27;数字&#x27;</span> + n + <span class="hljs-string">&#x27;是&#x27;</span> + (n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> ? <span class="hljs-string">&#x27;偶数&#x27;</span> : <span class="hljs-string">&#x27;奇数&#x27;</span>);<br><br></code></pre></td></tr></table></figure><p>上面代码利用三元运算符，输出相应的提示和在字符串之中插入不同的值。</p><h2 id="2-循环语句">2. 循环语句</h2><p>循环语句用于重复执行某个操作，它有多种形式。</p><h3 id="2-1-while-循环">2.1 <a href="">while</a> 循环</h3><p><a href="">while</a> 语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">while</span> (条件)<br>  语句;<br><span class="hljs-comment">// 或者</span><br><span class="hljs-keyword">while</span> (条件) 语句;<br><br><span class="hljs-comment">//多条语句</span><br><span class="hljs-keyword">while</span> (条件) &#123;<br>  语句一;<br>  ...<br>  语句N;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>while语句的循环条件是一个表达式，必须放在圆括号中。代码块部分，如果只有一条语句，可以省略大括号，否则就必须加上大括号。</p><h3 id="2-2-for-循环">2.2 <a href="">for</a> 循环</h3><p><a href="">for</a> 语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。它的格式如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (初始化表达式; 条件; 递增表达式)<br>  语句<br><br><span class="hljs-comment">// 或者</span><br><br><span class="hljs-keyword">for</span> (初始化表达式; 条件; 递增表达式) &#123;<br>  语句<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="">for</a> 语句后面的括号里面，有三个表达式。</p><blockquote><p>~</p><ul><li>初始化表达式（initialize）：确定循环变量的初始值，只在循环开始时执行一次。</li><li>条件表达式（test）：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。</li><li>递增表达式（increment）：每轮循环的最后一个操作，通常用来递增循环变量。</li></ul><p>~</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; x; i++) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>&#125;<br><span class="hljs-comment">// 0</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>上面代码中，初始化表达式是var i = 0，即初始化一个变量i；测试表达式是i &lt; x，即只要i小于x，就会执行循环；递增表达式是i++，即每次循环结束后，i增大1。</p><p>所有for循环，都可以改写成while循环。上面的例子改为while循环，代码如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span> (i &lt; x) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  i++;<br>&#125;<br></code></pre></td></tr></table></figure><p>for语句的三个部分（initialize、test、increment），可以省略任何一个，也可以全部省略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> ( ; ; )&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello World&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码省略了for语句表达式的三个部分，结果就导致了一个无限循环。</p><h3 id="2-3-do…while-循环">2.3 <a href="">do…while</a> 循环</h3><p><a href="">do…while</a> 循环与 <a href="">while</a> 循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">do</span><br>  语句<br><span class="hljs-keyword">while</span> (条件);<br><br><span class="hljs-comment">// 或者</span><br><span class="hljs-keyword">do</span> &#123;<br>  语句<br>&#125; <span class="hljs-keyword">while</span> (条件);<br><br><span class="hljs-comment">//eg:</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">do</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  i++;<br>&#125; <span class="hljs-keyword">while</span>(i &lt; x);<br><span class="hljs-comment">//0</span><br><span class="hljs-comment">//1</span><br><span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure><p>不管条件是否为真，<a href="">do…while</a> 循环至少运行一次，这是这种结构最大的特点。另外，while语句后面的分号注意不要省略。</p><h3 id="2-4-break-语句和-continue-语句">2.4 <a href="">break</a> 语句和 <a href="">continue</a> 语句</h3><p><a href="">break</a> 语句和<a href="">continue</a> 语句都具有跳转作用，可以让代码不按既有的顺序执行。</p><p><a href="">break</a> 语句用于跳出代码块或循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span>(i &lt; <span class="hljs-number">100</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;i 当前为：&#x27;</span> + i);<br>  i++;<br>  <span class="hljs-keyword">if</span> (i === <span class="hljs-number">10</span>) <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码只会执行10次循环，一旦i等于10，就会跳出循环。</p><p>for循环也可以使用break语句跳出循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  <span class="hljs-keyword">if</span> (i === <span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">// 0</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>上面代码执行到i等于3，就会跳出循环。</p><p><a href="">continue</a> 语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">100</span>)&#123;<br>  i++;<br>  <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;i 当前为：&#x27;</span> + i);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码只有在i为奇数时，才会输出i的值。如果i为偶数，则直接进入下一轮循环。</p><p>如果存在多重循环，不带参数的 <a href="">break</a> 语句和 <a href="">continue</a> 语句都只针对最内层循环。</p><h3 id="2-5-标签（label-）">2.5 标签（<a href="">label</a> ）</h3><p>JavaScript 语言允许，语句的前面有标签（<a href="">label</a> ），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">label</span>:<br>  语句<br></code></pre></td></tr></table></figure><p>标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。</p><p>标签通常与 <a href="">break</a> 语句和 <a href="">continue</a> 语句配合使用，跳出特定的循环。</p><p>[eg:]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">top</span>:<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)&#123;<br>      <span class="hljs-keyword">if</span> (i === <span class="hljs-number">1</span> &amp;&amp; j === <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span> top;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;i=&#x27;</span> + i + <span class="hljs-string">&#x27;, j=&#x27;</span> + j);<br>    &#125;<br>  &#125;<br><span class="hljs-comment">// i=0, j=0</span><br><span class="hljs-comment">// i=0, j=1</span><br><span class="hljs-comment">// i=0, j=2</span><br><span class="hljs-comment">// i=1, j=0</span><br></code></pre></td></tr></table></figure><p>上面代码为一个双重循环区块，<a href="">break</a> 命令后面加上了 <a href="">top</a> 标签（注意，top不用加引号），满足条件时，直接跳出双层循环。如果break语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。</p><blockquote><p>标签也可以用于跳出代码块。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">foo</span>: &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">break</span> foo;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;本行不会输出&#x27;</span>);<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><blockquote><p>上面代码执行到break foo，就会跳出区块。</p></blockquote><p>continue语句也可以与标签配合使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">top</span>:<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)&#123;<br>      <span class="hljs-keyword">if</span> (i === <span class="hljs-number">1</span> &amp;&amp; j === <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span> top;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;i=&#x27;</span> + i + <span class="hljs-string">&#x27;, j=&#x27;</span> + j);<br>    &#125;<br>  &#125;<br><span class="hljs-comment">// i=0, j=0</span><br><span class="hljs-comment">// i=0, j=1</span><br><span class="hljs-comment">// i=0, j=2</span><br><span class="hljs-comment">// i=1, j=0</span><br><span class="hljs-comment">// i=2, j=0</span><br><span class="hljs-comment">// i=2, j=1</span><br><span class="hljs-comment">// i=2, j=2</span><br></code></pre></td></tr></table></figure><p>上面代码中，<a href="">continue</a> 命令后面有一个标签名，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果continue语句后面不使用标签，则只能进入下一轮的内层循环</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
      <category>学习笔记</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>条件语句</tag>
      
      <tag>循环语句</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
