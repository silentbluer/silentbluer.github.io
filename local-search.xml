<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JavaScript的数据类型浅析</title>
    <link href="/2022/06/19/JavaScript%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%B5%85%E6%9E%90/"/>
    <url>/2022/06/19/JavaScript%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%B5%85%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-数据类型的概述">1. 数据类型的概述</h2><p>JavaScript类型可以分为两类：原始类型和对象类型。</p><h3 id="1-1-原始类型">1.1 原始类型</h3><blockquote><ul><li>JavaScript的原始类型包括 <strong>数值</strong> 、<strong>文本字符串</strong>（也称字符串）和 <strong>布尔真值</strong>（也称布尔值）。</li><li>JavaScript中的特殊值 <strong>null</strong> 和 <strong>undefined</strong> 也是原始值，但它们不是数值、字符串或布尔值。这两个值通常被认为是各自特殊类型的唯一成员。</li><li>ES6新增了一种特殊类型 <strong>Symbol</strong>（符号），用于对语言进行扩展而不破坏向后兼容性。</li></ul></blockquote><div class="note note-warning">            <p>原始值是固定而简单的值，是存放在栈(stack)中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。</p><p>引用值则是比较大的对象，存放在堆(heap)中的对象，也就是说，存储在变量处的值是一个指针(pointer)，指向存储对象的内存处。</p><p>所有引用类型都集成自Object。</p><p>如果一个值是引用类型的，那么它的存储空间将从堆中分配。由于引用值的大小会改变，所以不能把它放在栈中，否则会降低查询速度。相反，存放变量的栈空间中的值是该对象存储在堆中的地址。地址的大小是固定的，所以把它存放在栈中对变量性能无任何负面影响。</p><table><thead><tr><th>栈区stack</th><th></th><th>堆区heap</th></tr></thead><tbody><tr><td>数字(12)</td><td>原始值</td><td>object1</td></tr><tr><td>布尔值(true)</td><td>原始值</td><td>object2</td></tr><tr><td>null</td><td>原始值</td><td>object3</td></tr><tr><td>undefined</td><td>原始值</td><td>object4</td></tr><tr><td>string(‘test’)</td><td>原始值</td><td>object5</td></tr><tr><td>symbol</td><td>原始值</td><td>object6</td></tr><tr><td>地址（o）</td><td>引用值→</td><td>object7</td></tr></tbody></table>          </div><h3 id="1-2-对象类型">1.2 对象类型</h3><p>在JavaScript中，任何不是<strong>数值</strong>、<strong>字符串</strong>、<strong>布尔值</strong>、<strong>符号</strong>、<strong>null</strong>和<strong>undefined</strong>的值都是<strong>对象</strong>。</p><p><strong>对象</strong><small>（<u>也就是对象类型的成员</u>）</small>是 <em>属性</em> 的集合，其中每个<code>属性</code>都有一个<code>名字</code>和一个<code>值</code><small>（<u>原始值或其他对象</u>）</small>。</p><blockquote><ul><li>普通JavaScript对象是一个命名值的无序集合。</li><li>JavaScript自身定义了一种特殊对象，称为数组。数组表示一个数字值的有序集合。</li></ul></blockquote><div class="note note-info">            <blockquote><p>除了基本的<code>对象</code>和<code>数组</code>之外，JavaScript还定义了其他一些有用的对象类型。</p></blockquote><ul><li>Set对象表示一组值的集合，Map对象表示键与值的映射。</li><li>各种“定型数组”（typed array）类型便于对字节数组和其他二进制数据进行操作。</li><li>RegExp类型表示文本模式，可以实现对字符串的复杂匹配、搜索和替换操作。</li><li>Date类型表示日期和时间，支持基本的日期计算。</li><li>Error及其子类型表示JavaScript代码运行期间可能发生的错误。</li></ul>          </div><h3 id="1-3-数据类型特点">1.3 数据类型特点</h3><p>JavaScript的<code>对象类型</code>是可修改的（mutable），而它的<code>原始类型</code>是不可修改的（immutable）。</p><p>可修改类型的值可以改变，比如JavaScript程序可以修改对象属性和数组元素的值。</p><p><strong>数值</strong>、<strong>布尔值</strong>、<strong>符号</strong>、<strong>null</strong>和<strong>undefined</strong>是不可修改的，以数值为例，修改它是没有意义的。</p><p><strong>字符串</strong>可以看成字符数组，<u>字符串也是<span style="color:red;">不可</span>修改的</u>。虽然可以按索引访问字符串中的字符，但JavaScript没有提供任何方式去修改已有字符串的字符。</p><blockquote><p>常量和变量可以让我们在程序中使用名字来引用其值。</p></blockquote><p>常量使用<code>const</code>声明，变量使用<code>let</code>（或在较老的JavaScript代码中使用var）声明。<br>JavaScript常量和变量是无类型的（untyped），声明并不会限定要赋何种类型的值。</p><h2 id="2-数值-Number">2. 数值 Number</h2><h3 id="2-1-特点">2.1 特点</h3><p>JavaScript的主要数值类型Number用于表示整数和近似实数。JavaScript使用IEEE 754标准<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://blog.silentblue.top/2022/06/10/浅谈IEEE754标准的浮点数误差成因/">[1]</span></a></sup>定义的64位浮点格式表示数值，这种数值格式可以让我们准确表示-9 007 199 254 740 992（-2<sup>53</sup>）到9 007 199 254 740 992（2<sup>53</sup>）之间的所有整数（含首尾值）。如果你的数值超出了这个范围，那可能会在末尾的数字上损失一些精度。</p><p>但要注意，JavaScript中的某些操作（如数组索引和位操作）是以32位整数计算的。当数值真正出现在JavaScript程序中时，就叫作数值字面量（numeric literal）。JavaScript支持几种形式的数值字面量，任何数值字面量前面都可以加上一个减号（-）将数值变成负值。</p><h3 id="2-2-数值的进制与表示方法">2.2 数值的进制与表示方法</h3><p>在JavaScript程序中，基数为10的整数可以直接写成数字序列。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">3</span><br><span class="hljs-number">5</span><br><span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure><p>除了基数为10的整数字面量之外，JavaScript也支持十六进制（基数是16的）值。十六进制字面量以<code>0x</code>或<code>0X</code>开头，后跟一个十六进制数字字符串。十六进制数字是数字<code>0</code>到<code>9</code>和字母<code>a（或A）</code>到<code>f（或F）</code>，<code>a到f</code>表示<code>10到15</code>。下面是十六进制整数字面量的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">0xff</span> <span class="hljs-comment">// 255</span><br><span class="hljs-number">0o377</span> <span class="hljs-comment">// 255</span><br><span class="hljs-number">0b11</span> <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>在ES6及之后的版本中，也可以通过<code>二进制</code>（基数为2）或<code>八进制</code>（基数为8）表示整数，分别使用前缀<code>0b</code>和<code>0o</code>（或<code>0B</code>和<code>0O</code>）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">0b10101</span> <span class="hljs-comment">// 21 (1*16+0*8+1*4+0*2+1*1)</span><br><span class="hljs-number">0o377</span> <span class="hljs-comment">// 255 (3*64+7*8+7*1)</span><br></code></pre></td></tr></table></figure><div class="note note-info">            <table><thead><tr><th style="text-align:right">进制</th><th style="text-align:right">表示方法</th><th style="text-align:right">注意</th></tr></thead><tbody><tr><td style="text-align:right">二进制</td><td style="text-align:right">0b/0B</td><td style="text-align:right">默认情况下，JavaScript 内部会自动将八进制、十六进制、二进制转为十进制。</td></tr><tr><td style="text-align:right">八进制</td><td style="text-align:right">0o/0O</td><td style="text-align:right">如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报错。</td></tr><tr><td style="text-align:right">十进制</td><td style="text-align:right">无</td><td style="text-align:right">通常来说，有前导0的数值会被视为八进制，但是如果前导0后面有数字8和9，则该数值被视为十进制。</td></tr><tr><td style="text-align:right">十六进制</td><td style="text-align:right">0x/0X</td><td style="text-align:right">前导0表示八进制，处理时很容易造成混乱。ES5 的严格模式和 ES6，已经废除了这种表示法，但是浏览器为了兼容以前的代码，目前还继续支持这种表示法。</td></tr></tbody></table>          </div><p>浮点字面量可以包含小数点，它们对实数使用传统语法。实数值由数值的整数部分、小数点和数值的小数部分组成。</p><p>浮点字面量也可以使用指数记数法表示，即实数值后面可以跟字母e（或E），跟一个可选的加号或减号，再跟一个整数指数。这种记数法表示的是实数值乘以10的指数次幂。</p><blockquote><p>简明格式：<br>[digits][.digits][(E/e)[(+/-)]digits]</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">123e3</span> <span class="hljs-comment">// 123000 </span><br><span class="hljs-number">123e-3</span> <span class="hljs-comment">// 0.123</span><br>-<span class="hljs-number">3.1E+12</span><br><span class="hljs-number">.1e-23</span><br></code></pre></td></tr></table></figure><p>以下两种情况，JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示：</p><div class="note note-info">            <table><thead><tr><th style="text-align:right">规则</th><th style="text-align:right">实例</th></tr></thead><tbody><tr><td style="text-align:right">小数点前的数字<code>大于&gt;</code>21位</td><td style="text-align:right">1234567890123456789012  /=&gt; 1.2345678901234568e+21</td></tr><tr><td style="text-align:right">小数点后0<code>大于&gt;</code>5个</td><td style="text-align:right">0.0000003 /=&gt; 3e-7</td></tr></tbody></table>          </div><p><strong>数值字面量中的分隔符：</strong></p><p>可以用下划线将数值字面量分隔为容易看清的数字段：</p><blockquote><p>字节(byte)是计算机中数据处理的基本单位。 计算机中以字节(byte)为单位存储和解释信息，规定一个字节(byte)由八个二进制位构成，即1个字节等于8个比特（1Byte=8bit）。八位二进制数最小为0000_0000，最大为1111_1111；通常1个字节可以存入一个ASCII码，2个字节可以存放一个汉字国标码。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> billion = <span class="hljs-number">1_000_000_000</span>; <span class="hljs-comment">//以下划线作为千分位分隔符</span><br><span class="hljs-keyword">let</span> bytes = <span class="hljs-number">0X89_AB_CD_EF</span>;  <span class="hljs-comment">//作为字节分隔符</span><br><span class="hljs-keyword">let</span> bits = <span class="hljs-number">0b0001_1101_0111</span>; <span class="hljs-comment">//作为半字节分隔符</span><br><span class="hljs-keyword">let</span> fraction = <span class="hljs-number">0.123_456_789</span> <span class="hljs-comment">//作为小数部分分隔符</span><br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>数值字面量中像这样添加下划线还没有成为正式的JavaScript标准。但这个特性已经进入标准化流程的后期，而且已经被所有主流浏览器以及Node实现了。</p>          </div><h3 id="2-3-数学方法">2.3 数学方法</h3><p>JavaScript程序的算术操作符包括表示<code>加法</code>的<code>+</code>、表示<code>减法</code>的<code>-</code>、表示<code>乘法</code>的<code>*</code>、表示<code>除法</code>的<code>/</code>和表示<code>取模（除法后的余数）</code>的<code>%</code>。ES2016增加了<code>取幂</code>的<code>**</code>。</p><blockquote><p><code>幂</code>在数学里表示次方，求幂运算符（**）返回将第一个操作数加到第二个操作数的幂的结果(a ** b = a<sup>b</sup>)。<br><code>**</code>等效于Math.pow(a,b)，不同之处在于它也接受 BigInts 作为操作数。<br><code>**</code>是右结合的: a ** b ** c 等于 a ** (b ** c)<br>在 JavaScript里，不能将一个一元运算符（+/-/~/!/delete/void/typeof）放在基数前，会导致一个语法错误。</p></blockquote><!-- <span class="label label-warning">求幂运算符是是右结合的: a ** b ** c 等于 a ** (b ** c)</span> --><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span> ** <span class="hljs-number">4</span>);<br><span class="hljs-comment">// expected output: 81</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">10</span> ** -<span class="hljs-number">2</span>);<br><span class="hljs-comment">// expected output: 0.01</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span> ** <span class="hljs-number">3</span> ** <span class="hljs-number">2</span>);<br><span class="hljs-comment">// expected output: 512 </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-number">2</span> ** <span class="hljs-number">3</span>) ** <span class="hljs-number">2</span>);<br><span class="hljs-comment">// expected output: 64</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(-<span class="hljs-number">2</span> ** <span class="hljs-number">3</span>);<br><span class="hljs-comment">// SyntaxError  语法错误</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(-(<span class="hljs-number">2</span> ** <span class="hljs-number">3</span>));<br><span class="hljs-comment">// expected output: -8</span><br></code></pre></td></tr></table></figure><p>除了上述基本的算术操作符之外，JavaScript还通过Math对象的属性提供了一组函数和常量，以支持更复杂的数学计算：</p><div class="note note-primary">            <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>) <span class="hljs-comment">// =&gt; 64,2的5次方  &lt;==&gt;  2 ** 5</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(<span class="hljs-number">0.5</span>) <span class="hljs-comment">// =&gt;1,舍入到最近的整数</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(<span class="hljs-number">0.3</span>) <span class="hljs-comment">// =&gt;1,向上舍入到一个整数</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-number">0.8</span>) <span class="hljs-comment">// =&gt;0,向下舍入到一个整数</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(-<span class="hljs-number">5</span>) <span class="hljs-comment">// =&gt;5,取绝对值</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(x,y,z) <span class="hljs-comment">// 返回最大的参数</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(x,y,z) <span class="hljs-comment">// 返回最小的参数</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() <span class="hljs-comment">// 伪随机数x,其中0 ≤ x ＜ 1.0</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> <span class="hljs-comment">//圆周率Π</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-property">E</span> <span class="hljs-comment">// 自然对数的底数e,数学中常以logx表示自然对数</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">// &lt;==&gt; Math.pow(3,(1/2)) =&gt; 3 ** 0.5，求3的平方根</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>/<span class="hljs-number">3</span>) <span class="hljs-comment">// 3 ** (1/3),求3的立方根</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(<span class="hljs-number">0</span>) <span class="hljs-comment">// 三角函数，类似还有Math.acos()、Math.asin()、Math.atan()、</span><br>            <span class="hljs-comment">// Math.atan2()、Math.cos()、Math.tan()等</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">10</span>) <span class="hljs-comment">// 10的自然对数，此处底数应为e</span><br><span class="hljs-comment">/*  </span><br><span class="hljs-comment">1、a^x=N(a&gt;0,且a≠1)，则x叫做以a为底N的对数,记做x=log(a)(N)，其中a要写于log右下。</span><br><span class="hljs-comment">2、其中a叫做对数的底，N叫做真数。通常我们将以10为底的对数叫做常用对数，以e为底的对数称为自然对数。</span><br><span class="hljs-comment">3、log的底数是10时可以写成lg，底数是e时可以简写成ln。</span><br><span class="hljs-comment">4、log不写底数时，通场需结合上下文判断底数，但一般规律为：通常情况下是10；</span><br><span class="hljs-comment">计算机学科中是2（在计算时间复杂度时，底数可以忽略）；而编程语言中则是e。</span><br><span class="hljs-comment"> */</span> <br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">88</span>)/<span class="hljs-title class_">Math</span>.<span class="hljs-property">LN10</span> <span class="hljs-comment">// 以10为底，88的对数</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">88</span>)/<span class="hljs-title class_">Math</span>.<span class="hljs-property">LN2</span> <span class="hljs-comment">// 以2为底，88的对数</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">exp</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">// e^3,Math.E的立方</span><br></code></pre></td></tr></table></figure>          </div><span class="label label-warning">JS中的Math对象还有很多，ES6在Math对象上又新增了一批函数，有兴趣可自行研究JS中的Math对象<sup id=fnref:2 class=footnote-ref><a href=#fn:2 rel=footnote><span class=hint--top hint--rounded aria-label=Math内置对象 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math>[2]</span></a></sup></span><h3 id="2-4-特殊数值">2.4 特殊数值</h3><div class="note note-info">            <p>1、JavaScript中的算术在遇到<code>上溢出</code>、<code>下溢出</code>或<code>被零除</code>时不会发生错误。<br>在数值操作的结果超过最大可表示数值时（上溢出），结果是一个特殊的无穷值<code>Infinity</code>。<br>2、当某个负数的绝对值超过了最大可表示负数的绝对值时，结果是负无穷值<code>-Infinity</code>。<br><span class="label label-warning">这两个无穷值的行为跟我们的预期一样：任何数<code>加、减、乘、除</code>无穷值结果还是无穷值（只是符号可能相反）。</span></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">0</span>乘以<span class="hljs-title class_">Infinity</span>，返回<span class="hljs-title class_">NaN</span>；<span class="hljs-number">0</span>除以<span class="hljs-title class_">Infinity</span>，返回<span class="hljs-number">0</span>；<span class="hljs-title class_">Infinity</span>除以<span class="hljs-number">0</span>，返回<span class="hljs-title class_">Infinity</span>。<br><span class="hljs-number">0</span> * <span class="hljs-title class_">Infinity</span> <span class="hljs-comment">// NaN</span><br><span class="hljs-number">0</span> / <span class="hljs-title class_">Infinity</span> <span class="hljs-comment">// 0</span><br><span class="hljs-title class_">Infinity</span> / <span class="hljs-number">0</span> <span class="hljs-comment">// Infinity</span><br><br><span class="hljs-title class_">Infinity</span>加上或乘以<span class="hljs-title class_">Infinity</span>，返回的还是<span class="hljs-title class_">Infinity</span>。<br><span class="hljs-title class_">Infinity</span> + <span class="hljs-title class_">Infinity</span> <span class="hljs-comment">// Infinity</span><br><span class="hljs-title class_">Infinity</span> * <span class="hljs-title class_">Infinity</span> <span class="hljs-comment">// Infinity</span><br><br><span class="hljs-title class_">Infinity</span>减去或除以<span class="hljs-title class_">Infinity</span>，得到<span class="hljs-title class_">NaN</span>。<br><span class="hljs-title class_">Infinity</span> - <span class="hljs-title class_">Infinity</span> <span class="hljs-comment">// NaN</span><br><span class="hljs-title class_">Infinity</span> / <span class="hljs-title class_">Infinity</span> <span class="hljs-comment">// NaN</span><br><br><span class="hljs-title class_">Infinity</span>与<span class="hljs-literal">null</span>计算时，<span class="hljs-literal">null</span>会转成<span class="hljs-number">0</span>，等同于与<span class="hljs-number">0</span>的计算。<br><span class="hljs-literal">null</span> * <span class="hljs-title class_">Infinity</span> <span class="hljs-comment">// NaN</span><br><span class="hljs-literal">null</span> / <span class="hljs-title class_">Infinity</span> <span class="hljs-comment">// 0</span><br><span class="hljs-title class_">Infinity</span> / <span class="hljs-literal">null</span> <span class="hljs-comment">// Infinity</span><br><br><span class="hljs-title class_">Infinity</span>与<span class="hljs-literal">undefined</span>计算，返回的都是<span class="hljs-title class_">NaN</span>。<br><span class="hljs-literal">undefined</span> + <span class="hljs-title class_">Infinity</span> <span class="hljs-comment">// NaN</span><br><span class="hljs-literal">undefined</span> - <span class="hljs-title class_">Infinity</span> <span class="hljs-comment">// NaN</span><br><span class="hljs-literal">undefined</span> * <span class="hljs-title class_">Infinity</span> <span class="hljs-comment">// NaN</span><br><span class="hljs-literal">undefined</span> / <span class="hljs-title class_">Infinity</span> <span class="hljs-comment">// NaN</span><br><span class="hljs-title class_">Infinity</span> / <span class="hljs-literal">undefined</span> <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><p>3、下溢出发生在数值操作的结果比最小可表示数值更接近0的情况下。此时，JavaScript返回0。如果下溢出来自负数，JavaScript返回一个被称为“负零”的特殊值。这个值与常规的零几乎完全无法区分，几乎所有场合，正零和负零都会被当作正常的0。唯一有区别的场合是，+0或-0当作分母，返回的值是不相等的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">-<span class="hljs-number">0</span> === +<span class="hljs-number">0</span> <span class="hljs-comment">// true</span><br><span class="hljs-number">0</span> === -<span class="hljs-number">0</span> <span class="hljs-comment">// true</span><br><span class="hljs-number">0</span> === +<span class="hljs-number">0</span> <span class="hljs-comment">// true</span><br>(<span class="hljs-number">1</span> / +<span class="hljs-number">0</span>) === (<span class="hljs-number">1</span> / -<span class="hljs-number">0</span>) <span class="hljs-comment">// false</span><br><span class="hljs-comment">//上面的代码之所以出现这样结果，是因为除以正零得到+Infinity，</span><br><span class="hljs-comment">//除以负零得到-Infinity，这两者是不相等的</span><br></code></pre></td></tr></table></figure><p>4、被零除在JavaScript中不是错误，只会简单地返回<code>无穷(infinity)</code>或<code>负无穷(-infinity)</code>。<br>5、不过有一个例外：<code>0/0</code>是没有意义的值，这个操作的结果是一个特殊的“非数值”（<code>NaN</code>，Not a Number）。此外，<code>无穷除无穷(infinity/infinity)</code>、<code>负数平方根(Math.sqrt(-x))</code>或者用<code>无法转换为数值</code>的非数值作为算术操作符<code>的操作数</code>，结果也都是NaN。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">5</span> - <span class="hljs-string">&#x27;x&#x27;</span> <span class="hljs-comment">// NaN,代码运行时，会自动将字符串x转为数值，但是由于x不是数值，所以最后得到结果为NaN,</span><br><span class="hljs-comment">//用无法转换为数值的非数值作为算术操作符的操作数</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">acos</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">log</span>(-<span class="hljs-number">1</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(-<span class="hljs-number">1</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-number">0</span> / <span class="hljs-number">0</span> <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><p>6、需要注意的是，NaN不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于Number，使用typeof运算符可以看得很清楚。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">NaN</span> <span class="hljs-comment">// &#x27;number&#x27;</span><br></code></pre></td></tr></table></figure><p>7、NaN在布尔运算时被当作false。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Boolean</span>(<span class="hljs-title class_">NaN</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>8、NaN与任何数（包括它自己）的运算，得到的都是NaN。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">NaN</span> + <span class="hljs-number">32</span> <span class="hljs-comment">// NaN</span><br><span class="hljs-title class_">NaN</span> - <span class="hljs-number">32</span> <span class="hljs-comment">// NaN</span><br><span class="hljs-title class_">NaN</span> * <span class="hljs-number">32</span> <span class="hljs-comment">// NaN</span><br><span class="hljs-title class_">NaN</span> / <span class="hljs-number">32</span> <span class="hljs-comment">// NaN</span><br><span class="hljs-title class_">Infinity</span> &gt; <span class="hljs-title class_">NaN</span> <span class="hljs-comment">// false</span><br>-<span class="hljs-title class_">Infinity</span> &gt; <span class="hljs-title class_">NaN</span> <span class="hljs-comment">// false</span><br><span class="hljs-title class_">Infinity</span> &lt; <span class="hljs-title class_">NaN</span> <span class="hljs-comment">// false</span><br>-<span class="hljs-title class_">Infinity</span> &lt; <span class="hljs-title class_">NaN</span> <span class="hljs-comment">// false</span><br><span class="hljs-comment">//Infinity与NaN比较，总是返回false。</span><br></code></pre></td></tr></table></figure>          </div><h3 id="2-5-与数值相关的全局方法">2.5 与数值相关的全局方法</h3><p>JavaScript预定义了全局常量<code>Infinity</code>和<code>NaN</code>以对应<code>正无穷</code>和<code>非数值</code>。这些值也可以通过Number对象的属性获取：</p><h4 id="big-parseInt-big"><big><code>parseInt()</code></big></h4><hr><p><strong>1、基本用法：</strong></p><blockquote><p><strong>parseInt方法用于将字符串转为整数。</strong></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;123&#x27;</span>) <span class="hljs-comment">//123</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>如果字符串头部有空格，空格会被自动去除。</strong></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;    123&#x27;</span>) <span class="hljs-comment">//123</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>如果parseInt的参数不是字符串，则会先转为字符串再转换。</strong></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">1.23</span>) <span class="hljs-comment">//1</span><br><span class="hljs-comment">// &lt;==&gt; 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1.23&#x27;</span>) <span class="hljs-comment">//1</span><br></code></pre></td></tr></table></figure><p><big><span class="label label-warning">字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。</span></big></p><blockquote><p>1、parseInt的参数都是字符串，结果只返回字符串头部可以转为数字的部分。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;8a&#x27;</span>) <span class="hljs-comment">// 8</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;12**&#x27;</span>) <span class="hljs-comment">// 12</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;12.34&#x27;</span>) <span class="hljs-comment">// 12</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;15e2&#x27;</span>) <span class="hljs-comment">// 15</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;15px&#x27;</span>) <span class="hljs-comment">// 15</span><br></code></pre></td></tr></table></figure><p>2、如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;abc&#x27;</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;.3&#x27;</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;+&#x27;</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;+1&#x27;</span>) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure></blockquote><p><big><span class="label label-warning">parseInt的返回值只有两种可能，要么是一个十进制整数，要么是NaN。</span></big></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//如果字符串以0x或0X开头，parseInt会将其按照十六进制数解析。</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;0x10&#x27;</span>) <span class="hljs-comment">// 16</span><br><span class="hljs-comment">//如果字符串以0开头，将其按照10进制解析。</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;011&#x27;</span>) <span class="hljs-comment">// 11</span><br><span class="hljs-comment">//对于那些会自动转为科学计数法的数字，parseInt会将科学计数法的表示方法视为字符串，</span><br><span class="hljs-comment">//因此导致一些奇怪的结果。</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">1000000000000000000000.5</span>) <span class="hljs-comment">// 1,小数点前多于21位</span><br><span class="hljs-comment">// &lt;==&gt; 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1e+21&#x27;</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">0.0000008</span>) <span class="hljs-comment">// 8,小数点后多余5个0</span><br><span class="hljs-comment">// &lt;==&gt; 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;8e-7&#x27;</span>) <span class="hljs-comment">// 8</span><br></code></pre></td></tr></table></figure><p><strong>2、进制转换：</strong><br>parseInt方法还可以接受第二个参数（<code>2到36</code>之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，parseInt的第二个参数为10，即默认是十进制转十进制。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1000&#x27;</span>) <span class="hljs-comment">// 1000</span><br><span class="hljs-comment">// &lt;==&gt; 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1000&#x27;</span>, <span class="hljs-number">10</span>) <span class="hljs-comment">// 1000</span><br><br><span class="hljs-built_in">parseInt</span>方法可带参数进行进制的转换<br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1000&#x27;</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 二进制1000等于十进制的8</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1000&#x27;</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// 六进制1000等于十进制的216</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1000&#x27;</span>, <span class="hljs-number">8</span>) <span class="hljs-comment">// 八进制1000等于十进制的512</span><br><br>如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在<span class="hljs-number">2</span>到<span class="hljs-number">36</span>之间，才能得到有意义的结果，<br>超出这个范围，则返回<span class="hljs-title class_">NaN</span>。如果第二个参数是<span class="hljs-number">0</span>、<span class="hljs-literal">undefined</span>和<span class="hljs-literal">null</span>，则直接忽略。<br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-number">37</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// 10</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-literal">null</span>) <span class="hljs-comment">// 10</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// 10</span><br>  <br>如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。<br>如果最高位无法转换，则直接返回<span class="hljs-title class_">NaN</span>。<br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1546&#x27;</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;546&#x27;</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><p>如果parseInt的第一个参数不是字符串，会被先转为字符串。这会导致一些令人意外的结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">0x11</span>, <span class="hljs-number">36</span>) <span class="hljs-comment">// 43</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">0x11</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-title class_">String</span>(<span class="hljs-number">0x11</span>), <span class="hljs-number">36</span>)<br><span class="hljs-built_in">parseInt</span>(<span class="hljs-title class_">String</span>(<span class="hljs-number">0x11</span>), <span class="hljs-number">2</span>)<br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;17&#x27;</span>, <span class="hljs-number">36</span>) <span class="hljs-comment">//43</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;17&#x27;</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment">//1</span><br></code></pre></td></tr></table></figure><p>上面代码中，十六进制的0x11会被先转为十进制的17，再转为字符串。然后，再用36进制或二进制解读字符串17，最后返回结果43和1。</p><p>这种处理方式，对于八进制的前缀0，尤其需要注意。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">011</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// NaN</span><br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-title class_">String</span>(<span class="hljs-number">011</span>), <span class="hljs-number">2</span>)<br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-title class_">String</span>(<span class="hljs-number">9</span>), <span class="hljs-number">2</span>) <span class="hljs-comment">//NaN</span><br></code></pre></td></tr></table></figure><p>上面代码中，第一行的011会被先转为字符串9，因为9不是二进制的有效字符，所以返回NaN。如果直接计算parseInt(‘011’, 2)，011则是会被当作二进制处理，返回3。</p><p>JavaScript 不再允许将带有前缀0的数字视为八进制数，而是要求忽略这个0。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定。</p><h4 id="big-parseFloat-big"><big><code>parseFloat()</code></big></h4><hr><p><code>parseFloat</code>方法用于将一个字符串转为浮点数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;1.23&#x27;</span>) <span class="hljs-comment">//1.23</span><br></code></pre></td></tr></table></figure><p><em>1. 如果字符串符合科学计数法，则会进行相应的转换。</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;123e-2&#x27;</span>) <span class="hljs-comment">//1.23</span><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;0.0123e+2&#x27;</span>) <span class="hljs-comment">//1.23</span><br></code></pre></td></tr></table></figure><p><em>2. 如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;3.14more non-digit characters&#x27;</span>) <span class="hljs-comment">// 3.14</span><br></code></pre></td></tr></table></figure><p><em>3. parseFloat方法会自动过滤字符串前导的空格。</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;\t\v\r12.34\n &#x27;</span>) <span class="hljs-comment">// 12.34</span><br><span class="hljs-comment">// \&#x27; Single quote (&#x27;)</span><br><span class="hljs-comment">// \&quot; Double quote (&quot;)</span><br><span class="hljs-comment">// \a ASCII Bell (BEL)</span><br><span class="hljs-comment">// \b ASCII Backspace (BS)</span><br><span class="hljs-comment">// \f ASCII Formfeed (FF)</span><br><span class="hljs-comment">// \n ASCII Linefeed (LF)</span><br><span class="hljs-comment">// \N&#123;name&#125; Character named name in the Unicode database (Unicode only)</span><br><span class="hljs-comment">// \r ASCII Carriage Return (CR)</span><br><span class="hljs-comment">// \t ASCII Horizontal Tab (TAB)</span><br><span class="hljs-comment">// \uxxxx Character with 16-bit hex value xxxx (Unicode only) (1) </span><br><span class="hljs-comment">// \Uxxxxxxxx Character with 32-bit hex value xxxxxxxx (Unicode only) (2)</span><br><span class="hljs-comment">// \v ASCII Vertical Tab (VT)</span><br></code></pre></td></tr></table></figure><p><em>4. 如果参数不是字符串，则会先转为字符串再转换。</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseFloat</span>([<span class="hljs-number">1.23</span>]) <span class="hljs-comment">// 1.23</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-title class_">String</span>([<span class="hljs-number">1.23</span>])) <span class="hljs-comment">// 1.23</span><br></code></pre></td></tr></table></figure><p><em>5. 如果字符串的第一个字符不能转化为浮点数，则返回NaN。</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseFloat</span>([]) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;FF2&#x27;</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// NaN</span><br><br>上面代码中，尤其值得注意，<span class="hljs-built_in">parseFloat</span>会将空字符串转为<span class="hljs-title class_">NaN</span>。<br></code></pre></td></tr></table></figure><p>这些特点使得parseFloat的转换结果不同于Number函数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseFloat</span>(<span class="hljs-literal">true</span>)  <span class="hljs-comment">// NaN</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// 1</span><br><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// 0</span><br><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// 0</span><br><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;123.45#&#x27;</span>) <span class="hljs-comment">// 123.45</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-string">&#x27;123.45#&#x27;</span>) <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><h4 id="big-isNaN-big"><big><code>isNaN()</code></big></h4><hr><p><code>isNaN</code>方法可以用来判断一个值是否为<code>NaN</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">NaN</span>) <span class="hljs-comment">//true</span><br><span class="hljs-built_in">isNaN</span>(<span class="hljs-number">123</span>) <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><p><code>isNaN</code>只对<code>数值</code>有效，如果传入其他值，会被先转成数值。比如，<u>传入字符串的时候，字符串会被先转成NaN，所以最后返回true</u>，这一点要特别引起注意。也就是说，<strong>isNaN为true的值，有可能不是NaN，而是一个字符串</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>) <span class="hljs-comment">// true</span><br><span class="hljs-comment">// 相当于</span><br><span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">Number</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>)) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>出于同样的原因，对于对象和数组，isNaN也返回true。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">isNaN</span>(&#123;&#125;) <span class="hljs-comment">// true</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">Number</span>(&#123;&#125;)) <span class="hljs-comment">// true</span><br><br><span class="hljs-built_in">isNaN</span>([<span class="hljs-string">&#x27;xzy&#x27;</span>]) <span class="hljs-comment">// true</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">Number</span>([<span class="hljs-string">&#x27;xzy&#x27;</span>])) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>但是，对于空数组和只有一个数值成员的数组，isNaN返回false。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">isNaN</span>([]) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isNaN</span>([<span class="hljs-number">123</span>]) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isNaN</span>([<span class="hljs-string">&#x27;123&#x27;</span>]) <span class="hljs-comment">// false</span><br>上面代码之所以返回<span class="hljs-literal">false</span>，原因是<span class="hljs-string">`Number()`</span>把空数组、空格、以及<span class="hljs-title class_">NUll</span>按照<span class="hljs-number">0</span>来处理 <br></code></pre></td></tr></table></figure><p>因此，使用isNaN之前，最好判断一下数据类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myIsNaN</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;number&#x27;</span> &amp;&amp; <span class="hljs-built_in">isNaN</span>(value);<br>  <span class="hljs-comment">//结果为return true;函数才返回结果。等同于</span><br>  <span class="hljs-comment">// [typeof value === &#x27;number&#x27;] &amp;&amp; [isNaN(value)] 结果都为true,函数才返回结果。</span><br>  <span class="hljs-comment">//即 value为数值类型并且 isNan(value)结果为true，两个条件都需达成</span><br>&#125;<br></code></pre></td></tr></table></figure><p>判断NaN更可靠的方法是，利用<code>NaN</code>为<em>唯一</em>不等于自身的值的这个特点，进行判断。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myIsNaN</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-keyword">return</span> value !== value;<br>  <span class="hljs-comment">// x != x,有且仅当x为NaN时成立。</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="big-isFinite-big"><big><code>isFinite()</code></big></h4><hr><p><code>isFinite</code>方法返回一个布尔值，表示某个值是否为正常的数值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">isFinite</span>(<span class="hljs-title class_">Infinity</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isFinite</span>(-<span class="hljs-title class_">Infinity</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isFinite</span>(<span class="hljs-title class_">NaN</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isFinite</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isFinite</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">isFinite</span>(-<span class="hljs-number">1</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>除了<code>Infinity</code>、<code>-Infinity</code>、<code>NaN</code>和<code>undefined</code>这几个值会返回false，isFinite对于其他的数值都会返回true。</p><h3 id="2-6-big-Number对象的属性-big">2.6 <big>Number对象的属性</big></h3><hr><table><thead><tr><th>全局对象</th><th>结果释义</th><th>对应Number属性</th><th>结果释义</th></tr></thead><tbody><tr><td>Infinity</td><td>因为太大而无法表示的正数</td><td>Number.POSITIVE_INFINITY</td><td>相同</td></tr><tr><td>-Infinity</td><td>因为太大而无法表示的负数</td><td>Number.NAGATIVE_INFINITY</td><td>相同</td></tr><tr><td>1/0</td><td>Infinity</td><td>Number.MAX_VALUE *2</td><td>Infinity;溢出</td></tr><tr><td>-1/0</td><td>-Infinity</td><td>-Number.MAX_VALUE *2</td><td>-Infinity;</td></tr><tr><td>NaN</td><td>非数值</td><td>Number.NaN</td><td>非数值；与全局写法不同而已</td></tr><tr><td>0/0</td><td>NaN</td><td>Infinity/Infinity</td><td>NaN</td></tr><tr><td>Number.MIN_VALUE / 2</td><td>0;下溢出</td><td>-Number.MIN_VALUE/2</td><td>-0</td></tr><tr><td>-1/Infinity</td><td>-0</td><td>-0 /Infinity</td><td>-0</td></tr></tbody></table><blockquote><p><em>ES6新增Number属性</em></p></blockquote><table><thead><tr><th>ES6定义的属性</th><th>对应全局函数</th><th>属性释义</th></tr></thead><tbody><tr><td>Number.parseInt()</td><td>parseInt()</td><td>一致</td></tr><tr><td>Number.parseFloat()</td><td>parseFloat()</td><td>一致</td></tr><tr><td>Number.isNan()</td><td>isNaN()</td><td>判断是不是NaN,在参数是NaN时，或者在参数是无法转换为数值的非数值时返回true</td></tr><tr><td>Number.isFinite()</td><td>isFinite()</td><td>Number.isFinite()在参数不是NaN、Infinity或-Infinity时返回true。<br>全局isFinite()函数在参数是有限数或者可以转换为有限数时返回true</td></tr><tr><td>Number.isInteger()</td><td></td><td>用来判断给定的参数是否为整数。<br>注意 NaN 和正负 Infinity 不是整数</td></tr><tr><td>Number.isSafeInteger()</td><td></td><td>用来判断传入的参数值是否是一个“安全整数”,安全整数范围为 -(2^53 - 1) 到 2^53 - 1 之间的整数，包含 -(2^53 - 1) 和 2^53 - 1</td></tr><tr><td>Number.MIN_SAFE_INTEGER</td><td></td><td>-(2^53 - 1)</td></tr><tr><td>Number.MAX_SAFE_INTEGER</td><td></td><td>(2^53 - 1)</td></tr><tr><td>Number.EPSILON</td><td></td><td>表示 1 与Number可表示的大于 1 的最小的浮点数之间的差值<br>(可理解为两个数值之间最小的误差值，例如，0.1+0.2!=0.3,但是，如果0.1+0.2-0.3 &lt; <code>Number.EPSILON</code>的话，即可证明0.1+0.2===0.3)；<br>不必创建Number对象可直接使用。<br>EPSILON 属性的值接近于 2.2204460492503130808472633361816E-16，或者 2^-52；</td></tr></tbody></table><h3 id="2-7-通过BigInt表示任意精度整数">2.7 通过BigInt表示任意精度整数</h3><h4 id="BigInt的介绍">BigInt的介绍</h4><hr><ol><li><p>什么是BigInt?<br>BigInt是一种新的数据类型，用于当整数值大于Number数据类型支持的范围时。这种数据类型允许我们安全地对大整数执行算术操作，表示<code>高分辨率的时间戳</code>，使用<code>大整数ID</code>等等，而不需要使用库。也就是说，BigInt 可以表示任意大的整数。</p></li><li><p>为什么需要BigInt?<br><code>在JS中，所有的数字都以双精度64位浮点格式表示，那这会带来什么问题呢？</code><br>这导致JS中的Number无法精确表示非常大的整数，它会将非常大的整数四舍五入:<br><small style="color:red;"><strong>一是</strong></small> 数值的精度只能到 53 个二进制位（相当于 16 个十进制位），大于这个范围的整数，JavaScript 是无法精确表示的。确切地说，JS中的 Number类型只能安全地表示<code>-9007199254740991(-(2^53-1))</code>和<code>9007199254740991((2^53-1))</code>，任何超出此范围的整数值都可能失去精度。这使得 JavaScript 不适合进行科学和金融方面的精确计算。<br><small style="color:red;"><strong>二是</strong></small> 大于或等于2的1024次方的数值，JavaScript 无法表示，会返回Infinity。</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 超过 53 个二进制位的数值，无法保持精度</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">53</span>) === <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">53</span>) + <span class="hljs-number">1</span> <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">9999999999999999999</span>); <span class="hljs-comment">// 10000000000000000000</span><br> <br><span class="hljs-comment">// 超过 2 的 1024 次方的数值，无法表示</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1024</span>) <span class="hljs-comment">// Infinity</span><br><br><span class="hljs-comment">//同时也会有一定的安全性问题：</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">9007199254740992</span> === <span class="hljs-number">9007199254740993</span>);<br><span class="hljs-comment">// true </span><br></code></pre></td></tr></table></figure><ol start="3"><li>如何创建并使用BigInt？</li></ol><blockquote><p>要创建BigInt，只需要在数字末尾追加n即可。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">9007199254740995</span>);<br><span class="hljs-comment">// 9007199254740996</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">9007199254740995n</span>);<br><span class="hljs-comment">// 9007199254740995n</span><br></code></pre></td></tr></table></figure><blockquote><p>另一种创建BigInt的方法是用BigInt()构造函数。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> num = <span class="hljs-title class_">BigInt</span>(<span class="hljs-string">&quot;9007199254740995&quot;</span>); <br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);<br><span class="hljs-comment">// 9007199254740995n</span><br></code></pre></td></tr></table></figure><h4 id="BigInt的应用场景">BigInt的应用场景</h4><hr><p><strong>高精度时间戳</strong></p><blockquote><p>大于 2^53 - 1 的整数的一个应用场景就是高精度时间戳。精确到纳秒级别的时间戳很常见，经常用来记录特定程序的执行事件，以便进行性能分析，BigInt 可以表示高精度时间戳，在后端性能分析、性能调优中发挥作用。</p></blockquote><p><strong>大整数 ID</strong></p><blockquote><p>比如 Twitter 的 id 生成服务(Snowflake 雪花算法)，当 id 持续增长时，就会超出 JS 的安全范围，因此要求同时冗余地返回字符串型的 id。假如有 BigInt 类型就可以直接使用。</p></blockquote><p>总体而言，BigInt 可以表示任意大的整数，目前的使用场景是相对较少的。BigInt 的使用需要注意的点还是非常多的，因而建议仅在值可能大于2^53 时使用 BigInt 类型。目前的兼容性一般，可以考虑使用 <a href="https://github.com/GoogleChromeLabs/jsbi">JSBI</a> 这个库替代。</p><h4 id="BigInt的使用及注意事项">BigInt的使用及注意事项</h4><hr><p><strong>简洁使用如下：</strong></p><blockquote><ol><li>BigInt 大多数情况下可以像常规数字类型一样使用。</li><li>为了与 Number 类型进行区分，BigInt 类型的数据必须添加后缀n。</li><li>BigInt 与普通整数是两种值，它们之间并不相等。Number 和 BigInt 可以进行比较，非严格相等。</li><li>由于 BigInt 与 Number 完全属于两种类型,并且不会进行隐式转换，所以没有办法进行混合运算。想要运算的话，必须将两种数据类型转换为同一种类型后，方可进行计算。因为隐式类型转换可能丢失信息，当混合使用大整数和浮点数时，结果值可能无法由BigInt或Number精确表示。建议仅在值可能大于2^53 时使用 BigInt 类型。</li><li>BigInt 不支持一元加法。一元加法运算符 <code>+value</code>，是大家熟知的将 <code>value</code> 转换成数字类型的方法。为了避免混淆，在 bigint 中不支持一元加法。</li><li><code>typeof</code> 检测 <code>BigInt</code> 对象返回 <code>bigint</code> 字符串。</li><li>当 <code>Boolean</code> 类型与 <code>BigInt</code> 类型相遇时，BigInt的处理方式与Number类似，换句话说，只要不是 0n，BigInt就被视为truthy的值。</li><li>元素都为<code>BigInt</code>的数组可以进行<code>sort排序</code>。排序BigInts和 numbers数组时，不会发生隐式类型转换。</li><li><code>BigInt</code>可以正常地进行<code>位运算</code>，如 |、&amp;、&gt; 和 ^。</li><li>不能将<code>BigInt</code>传递给<code>Web api</code> 和内置的 <code>JS 函数</code>，这些函数需要一个 <code>Number</code> 类型的数字，尝试这样做会报TypeError错误；使用 Object、String 等内置对象转换时，类似于 Number数字。</li><li>由于 BigInt 并不是一个构造函数，所以，不能使用 new BigInt() 的方式来构建实例</li><li>当创建一个 BigInt 的时候，参数必须为整数，否则或报错</li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">eg1</span>:<br><span class="hljs-comment">// BigInt大多数情况下可以像常规数字类型一样使用</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">10n</span> + <span class="hljs-number">20n</span>);  <span class="hljs-comment">// 30n</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1n</span> + <span class="hljs-number">2n</span>); <span class="hljs-comment">// 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5n</span> / <span class="hljs-number">2n</span>); <span class="hljs-comment">// 2,除法 5/2 的结果2.5向零进行舍入到2，舍入后得到的结果没有了小数部分。</span><br><br><br><span class="hljs-attr">eg2</span>:<br><span class="hljs-keyword">let</span> a=<span class="hljs-number">12</span> ;<span class="hljs-comment">// 普通Number</span><br><span class="hljs-keyword">let</span> b=<span class="hljs-number">12n</span>; <span class="hljs-comment">// BigInt</span><br><br><span class="hljs-attr">eg3</span>:<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">12n</span> === <span class="hljs-number">12</span>) <span class="hljs-comment">// false,BigInt 与普通整数是两种值，它们之间并不相等</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">12n</span> == <span class="hljs-number">12</span>) <span class="hljs-comment">// true,非严格相等</span><br><br><br><span class="hljs-attr">eg4</span>:<br><span class="hljs-comment">// 与Number 类型无法进行混合运算</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">10</span> + <span class="hljs-number">20n</span>);  <span class="hljs-comment">// Uncaught TypeError</span><br><span class="hljs-comment">//BigInt和Number的相互转化</span><br><span class="hljs-keyword">let</span> bigint = <span class="hljs-number">20n</span>;<br><span class="hljs-keyword">let</span> number = <span class="hljs-number">10</span>;<br><span class="hljs-comment">// 将 number 转换为 bigint</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bigint + <span class="hljs-title class_">BigInt</span>(number)); <span class="hljs-comment">// 30n</span><br><span class="hljs-comment">// 将 bigint 转换为 number</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>(bigint) + number); <span class="hljs-comment">// 30</span><br><span class="hljs-comment">//转换操作始终是静默的，绝不会报错，但是如果 bigint 太大而数字类型无法容纳，</span><br><span class="hljs-comment">//则会截断多余的位，因此我们应该谨慎进行此类转换。</span><br><span class="hljs-keyword">const</span> min = <span class="hljs-title class_">Number</span>.<span class="hljs-property">MIN_SAFE_INTEGER</span>; <span class="hljs-comment">// -9007199254740891</span><br><span class="hljs-keyword">const</span> max = <span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_SAFE_INTEGER</span>; <span class="hljs-comment">// 9007199254740991</span><br><span class="hljs-comment">// number中</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-property">MIN_SAFE_INTEGER</span> - <span class="hljs-number">100</span>)  <span class="hljs-comment">// -- 并不是我们想要的那个数 </span><br><span class="hljs-comment">// 使用BigInt</span><br><span class="hljs-title class_">BigInt</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-property">MIN_SAFE_INTEGER</span>) - <span class="hljs-number">100n</span>  <span class="hljs-comment">// 得到正确的结果 -9007199254741091n</span><br><span class="hljs-title class_">BigInt</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-property">MIN_SAFE_INTEGER</span>) + <span class="hljs-number">1000n</span> <span class="hljs-comment">// 9007199254741991n</span><br><br><span class="hljs-attr">eg5</span>:<br><span class="hljs-comment">//BigInt 不支持一元加法</span><br><span class="hljs-keyword">let</span> bigint = <span class="hljs-number">1n</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(+bigint); <br><span class="hljs-comment">// TypeError: Cannot convert a BigInt value to a number</span><br><br><span class="hljs-attr">eg6</span>:<br><span class="hljs-comment">//typeof 运算符对于 BigInt 类型的数据返回 bigint。</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-number">20n</span>); <br><span class="hljs-comment">// bigint</span><br><br><span class="hljs-attr">eg7</span>:<br><span class="hljs-comment">//只要不是 0n，BigInt就被视为truthy的值</span><br><span class="hljs-keyword">if</span> (<span class="hljs-number">0n</span>) &#123;<br>  <span class="hljs-comment">// 永远不会执行</span><br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-number">3n</span>) &#123;<br>    <span class="hljs-comment">// 代码会被执行</span><br>&#125;<br><br><span class="hljs-attr">eg8</span>:<br><span class="hljs-keyword">let</span> numsSt=[<span class="hljs-number">3n</span>,<span class="hljs-number">2n</span>,<span class="hljs-number">5n</span>,<span class="hljs-number">8n</span>,<span class="hljs-number">6n</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numsSt.<span class="hljs-title function_">sort</span>()); <span class="hljs-comment">//[2n, 3n, 5n, 6n, 8n]</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">10n</span>, <span class="hljs-number">2n</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1n</span>, <span class="hljs-number">0</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">sort</span>());  <span class="hljs-comment">//[0, 1n, 10n, 2n, 4, 6, 9]</span><br><br><span class="hljs-attr">eg9</span>:<br><span class="hljs-comment">//BigInt可以正常地进行位运算，如 |、&amp;、&gt; 和 ^。</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-number">2n</span> &gt; <span class="hljs-number">1n</span> ); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-number">2n</span> &gt; <span class="hljs-number">1</span> ); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-number">1n</span> || <span class="hljs-number">2</span> ); <span class="hljs-comment">// 1（1n 被认为是真）</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-number">0n</span> || <span class="hljs-number">2</span> ); <span class="hljs-comment">// 2（0n 被认为是假）</span><br><br><span class="hljs-attr">eg10</span>:<br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(-<span class="hljs-number">2n</span>);       <span class="hljs-comment">// -&gt; TypeError</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">2n</span>, <span class="hljs-number">6n</span>);    <span class="hljs-comment">// -&gt; TypeError</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(<span class="hljs-number">2.</span><span class="hljs-number">56n</span>);    <span class="hljs-comment">// -&gt; TypeError</span><br><span class="hljs-comment">//object toString</span><br><span class="hljs-number">12n</span>.<span class="hljs-title function_">toString</span>()   <span class="hljs-comment">// -&gt;&#x27;12&#x27;</span><br><span class="hljs-number">12.</span><span class="hljs-title function_">toString</span>()    <span class="hljs-comment">// -&gt;&#x27;12&#x27;</span><br><span class="hljs-title class_">Object</span>(<span class="hljs-number">12n</span>)      <span class="hljs-comment">// -&gt; BigInt &#123;12n&#125;</span><br><span class="hljs-title class_">Object</span>(<span class="hljs-number">12</span>)       <span class="hljs-comment">// -&gt; Number &#123;12&#125;</span><br><br><span class="hljs-attr">eg11</span>:<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">BigInt</span>() <br><span class="hljs-comment">// Uncaught TypeError: BigInt is not a constructor at new BigInt</span><br><br><span class="hljs-attr">eg12</span>:<br><span class="hljs-title class_">BigInt</span>(<span class="hljs-number">1.2</span>) <br><span class="hljs-comment">// Uncaught RangeError: The number 1.2 cannot be converted to a BigInt </span><br><span class="hljs-comment">//because it is not an integer</span><br></code></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><table><thead><tr><th>语法点</th><th>支持度</th><th>备注</th></tr></thead><tbody><tr><td>+、*、-、**、%</td><td>支持</td><td></td></tr><tr><td>/</td><td>不支持</td><td>会进行向下取整</td></tr><tr><td>单目 (+) 运算符</td><td>不支持</td><td></td></tr><tr><td>&gt;&gt;&gt;（无符号右移）</td><td>不支持</td><td>因为 BigInt 都是有符号的，最高位表示正负</td></tr><tr><td>位运算（除了无符号右移）</td><td>支持</td><td></td></tr><tr><td>Math 对象方法</td><td>不支持</td><td></td></tr></tbody></table><h3 id="2-8-日期和时间的数值表示形式">2.8 日期和时间的数值表示形式</h3><p>JavaScript为表示和操作与日期及时间相关的数据而定义了简单的Date类。<br>JavaScript的Date是对象，但也有数值表示形式，即自1970年1月1日起至今的<code>毫秒数</code>，也叫<code>时间戳</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> timestamp = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<span class="hljs-comment">//当前时间的时间戳（Number）</span><br><span class="hljs-keyword">let</span> now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(); <span class="hljs-comment">//当前时间的日期对象</span><br><span class="hljs-keyword">let</span> ms=now.<span class="hljs-title function_">getTime</span>(); <span class="hljs-comment">//转化为毫秒时间戳</span><br><span class="hljs-keyword">let</span> iso = now.<span class="hljs-title function_">toIOSString</span>();<span class="hljs-comment">//转化为标准格式字符串</span><br></code></pre></td></tr></table></figure><h2 id="3-字符串-String">3. 字符串 String</h2><ul><li>JavaScript中表示文本的类型是String，即字符串。</li><li>字符串String类型是由引号括起来的一组由16位Unicode字符组成的不可修改的字符有序序列，其中每个值都表示一个Unicode字符。</li><li>字符串类型常被用于表示文本数据，此时字符串中的每个<code>元素</code>都被视为一个<code>代码点</code>。每个元素都被认为占有此序列中的一个位置，用非负数值索引这些位置。首字符从位置0开始，第二个字符在位置1，依次类推，字符串的长度即其中元素的个数（包含16位值的个数）。空字符串长度为零，因而不包含任何元素。</li><li>javascript没有表示单个字符的字符型，只有字符串String类型，单个字符的字符型相当于仅包含一个字符的字符串。</li></ul><h3 id="3-1-Unicode编码">3.1 Unicode编码</h3><p>JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。</p><p>JavaScript 不仅以 <code>Unicode</code> 储存字符，还允许直接在程序中使用 <code>Unicode 码点</code>表示字符，即将字符写成<code>\uxxxx</code>的形式，其中<code>xxxx</code>代表该字符的 <code>Unicode 码点</code>。比如，<code>\u00A9</code>代表版权符号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> cp=<span class="hljs-string">&#x27;\u00A9&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cp);<span class="hljs-comment">// ©</span><br></code></pre></td></tr></table></figure><p>解析代码的时候，JavaScript 会自动识别一个字符是字面形式表示，还是 <code>Unicode</code> 形式表示。输出给用户的时候，所有字符都会转成字面形式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> f\u006F\u006F = <span class="hljs-string">&#x27;abc&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo); <span class="hljs-comment">// &quot;abc&quot;</span><br><span class="hljs-comment">//第一行的变量名foo是 Unicode 形式表示，第二行是字面形式表示。JavaScript 会自动识别。</span><br></code></pre></td></tr></table></figure><p>若一个字符串包含实际的文本数据，则每个元素都被认为是一个单独的<code>UTF-16</code>单元。每个字符在 JavaScript 内部都是以<code>16位</code>（即<code>2个字节</code>）的 <code>UTF-16</code> 格式储存。也就是说，JavaScript 的单位字符长度固定为<code>16位</code>长度，即<code>2个字节</code>。</p><p>但UTF-16有两种长度：对于码点<code>U+0000</code>到<code>U+FFFF</code>之间的字符，长度为<code>16位</code>(即<code>2个字节</code>)；对于码点<code>U+10000</code>到<code>U+10FFFF</code>之间的字符，长度为<code>32位</code>(即<code>4个字节</code>)，而且前两个字节在<code>0xD800</code>到<code>0xDBFF</code>之间，后两个字节在<code>0xDC00</code>到<code>0xDFFF</code>之间。</p><p>举例来说，<code>U+1D306</code>对应的字符<code>𝌆</code>，写成UTF-16就是<code>0xD834 0xDF06</code>。浏览器会正确将这四个字节识别为一个字符，但是javascript内部的字符长度总是固定为16位，会把这四个字节视为两个字符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> cp = <span class="hljs-string">&#x27;\uD834\uDF06&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cp); <span class="hljs-comment">// 𝌆</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cp.<span class="hljs-property">length</span>); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>JavaScript 对 UTF-16 的支持是不完整的，由于历史原因，只支持两字节的字符，不支持四字节的字符。这是因为 JavaScript 第一版发布的时候，Unicode 的码点只编到U+FFFF，因此两字节足够表示了。</p><p>后来，Unicode 纳入的字符越来越多，出现了四字节的编码。但是，JavaScript 的标准此时已经定型了，统一将字符长度限制在两字节，导致无法识别四字节的字符。</p><p>类似<code>𝌆</code>的四字节字符，浏览器会正确识别这是一个字符，但是 JavaScript 无法识别，会认为这是两个字符。</p><p>注意，对于码点在<code>U+10000</code>到<code>U+10FFFF</code>之间的字符，JavaScript 总是认为它们是<code>两个字符</code>（<code>length属性为2</code>）。所以处理的时候，必须把这一点考虑在内，也就是说，<strong>JavaScript 返回的字符串长度可能是不正确的</strong>。</p>          </div><h3 id="3-2-引号">3.2 引号</h3><p>字符串String是由双引号(<code>&quot;</code>)或单引号(<code>'</code>)声明的。而Java则是用双引号声明字符串，用单引号声明字符。由于ECMAScript 没有字符类型，所以可使用这两种表示法中的任何一种，但左右引号必须匹配。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//正确</span><br><span class="hljs-keyword">const</span> sColor1 = <span class="hljs-string">&quot;red&quot;</span>;<br><span class="hljs-keyword">const</span> sColor2 = <span class="hljs-string">&#x27;red&#x27;</span>;<br><span class="hljs-comment">//错误</span><br><span class="hljs-keyword">const</span> sColor1 = <span class="hljs-string">&quot;red&#x27;; </span><br><span class="hljs-string">const sColor2 = &#x27;red&quot;</span>;<br></code></pre></td></tr></table></figure><p>由单引号定界的字符串中可以包含双引号，由双引号定界的字符串也可以包含单引号,如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠，用来转义。双引号字符串内部使用双引号，也是如此。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;key = &quot;value&quot;&#x27;</span><br><span class="hljs-string">&quot;It&#x27;s a long journey&quot;</span><br><br><span class="hljs-string">&#x27;Did she say \&#x27;Hello\&#x27;?&#x27;</span><br><span class="hljs-comment">// &quot;Did she say &#x27;Hello&#x27;?&quot;</span><br><span class="hljs-string">&quot;Did she say \&quot;Hello\&quot;?&quot;</span><br><span class="hljs-comment">// &quot;Did she say &quot;Hello&quot;?&quot;</span><br></code></pre></td></tr></table></figure><span class="label label-warning">javascript代码可能会夹杂HTML代码的字符串，HTML代码也会夹杂javascript代码。因此，最好在javascript和HTML代码中各自使用独自的引号风格。</span><p><code>javascript</code>中使用<code>单引号</code>表示字符串，在<code>HTML</code>事件处理程序中使用<code>双引号</code>表示字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;button onclick = <span class="hljs-string">&quot;alert(&#x27;thanks&#x27;)&quot;</span>&gt;click me&lt;/button&gt;<br></code></pre></td></tr></table></figure><h3 id="3-3-反斜线">3.3 反斜线<code>'\'</code></h3><p>字符串默认只能写在一行内，分成多行将会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;a</span><br><span class="hljs-string">b</span><br><span class="hljs-string">c&#x27;</span><br><span class="hljs-comment">// SyntaxError: Unexpected token ILLEGAL</span><br></code></pre></td></tr></table></figure><p>上面代码将一个字符串分成三行，JavaScript 就会报错。</p><p>如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> longString = <span class="hljs-string">&#x27;Long \</span><br><span class="hljs-string">long \</span><br><span class="hljs-string">long \</span><br><span class="hljs-string">string&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(longString);<br><span class="hljs-comment">// &quot;Long long long string&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码表示，加了反斜杠以后，原来写在一行的字符串，可以分成多行书写。但是，输出的时候还是单行，效果与写在同一行完全一样。注意，反斜杠的后面必须是换行符，而不能有其他字符（比如空格），否则会报错。</p><p>连接运算符（+）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> longString = <span class="hljs-string">&#x27;Long &#x27;</span><br>  + <span class="hljs-string">&#x27;long &#x27;</span><br>  + <span class="hljs-string">&#x27;long &#x27;</span><br>  + <span class="hljs-string">&#x27;string&#x27;</span>;<br></code></pre></td></tr></table></figure><p>如果想输出多行字符串，有一种利用多行注释的变通方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/*</span><br><span class="hljs-comment">line 1</span><br><span class="hljs-comment">line 2</span><br><span class="hljs-comment">line 3</span><br><span class="hljs-comment">*/</span>&#125;).<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;\n&#x27;</span>).<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;\n&#x27;</span>)<br><span class="hljs-comment">// &quot;line 1</span><br><span class="hljs-comment">// line 2</span><br><span class="hljs-comment">// line 3&quot;</span><br></code></pre></td></tr></table></figure><p>上面的例子中，输出的字符串就是多行。</p><h3 id="3-4-转义字符">3.4 转义字符</h3><p>在javascript字符串，反斜线(<code>\</code>)有着特殊的用途，反斜线符号后加一个字符，就不表示它们的字面含义，用来表示一些特殊字符，称为转义字符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">\<span class="hljs-number">0</span> ：<span class="hljs-literal">null</span>（\u0000）<br>\b ：后退键（\u0008）<br>\f ：换页符（\u000C）<br>\n ：换行符（\u000A）<br>\r ：回车键（\u000D）<br>\t ：制表符（\u0009）<br>\v ：垂直制表符（\u000B）<br>\<span class="hljs-string">&#x27; ：单引号（\u0027）</span><br><span class="hljs-string">\&quot; ：双引号（\u0022）</span><br><span class="hljs-string">\\ ：反斜杠（\u005C）</span><br></code></pre></td></tr></table></figure><p>上面这些字符前面加上反斜杠，都表示特殊含义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1\n2&#x27;</span>)<br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>上面代码中，\n表示换行，输出的时候就分成了两行。</p><p>反斜杠还有三种特殊用法。</p><p>（1）\DDD</p><p>反斜杠后面紧跟三个八进制数（000到377），代表一个字符。DDD对应该字符的 Unicode 码点，比如\251表示版权符号。显然，这种方法只能输出256种字符。</p><p>（2）\xDD</p><p>\x后面紧跟两个十六进制数（00到FF），代表一个字符。HH对应该字符的 Unicode 码点，比如\xA9表示版权符号。这种方法也只能输出256种字符。</p><p>（3）\uXXXX</p><p>\u后面紧跟四个十六进制数（0000到FFFF），代表一个字符。XXXX对应该字符的 Unicode 码点，比如\u00A9表示版权符号。</p><p>下面是这三种字符特殊写法的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;\251&#x27;</span> <span class="hljs-comment">// &quot;©&quot;</span><br><span class="hljs-string">&#x27;\xA9&#x27;</span> <span class="hljs-comment">// &quot;©&quot;</span><br><span class="hljs-string">&#x27;\u00A9&#x27;</span> <span class="hljs-comment">// &quot;©&quot;</span><br><br><span class="hljs-string">&#x27;\172&#x27;</span> === <span class="hljs-string">&#x27;z&#x27;</span> <span class="hljs-comment">// true</span><br><span class="hljs-string">&#x27;\x7A&#x27;</span> === <span class="hljs-string">&#x27;z&#x27;</span> <span class="hljs-comment">// true</span><br><span class="hljs-string">&#x27;\u007A&#x27;</span> === <span class="hljs-string">&#x27;z&#x27;</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>如果在非特殊字符前面使用反斜杠，则反斜杠会被省略。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;\a&#x27;</span><br><span class="hljs-comment">// &quot;a&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，a是一个正常字符，前面加反斜杠没有特殊含义，反斜杠会被自动省略。</p><p>如果字符串的正常内容之中，需要包含反斜杠，则反斜杠前面需要再加一个反斜杠，用来对自身转义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&quot;Prev \\ Next&quot;</span><br><span class="hljs-comment">// &quot;Prev \ Next&quot;</span><br></code></pre></td></tr></table></figure><h3 id="3-5-存储更改">3.5 存储更改</h3><p>javascript中的字符串是不可变的。一旦字符串被创建，就永远无法改变它。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。</p><p>可以通过+运算符连接其他字符串来创建一个新字符串(Symbol.toPrimitive的抽象操作)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> lang = <span class="hljs-string">&quot;java&quot;</span>;<br>lang = lang + <span class="hljs-string">&quot;script&quot;</span>; <span class="hljs-comment">//&#x27;javascript&#x27;</span><br><br><span class="hljs-string">&#x27;&#x27;</span> + [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-comment">// &quot;1,2,3&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>以上代码的实际过程是：<br>首先创建一个能够容纳10个字符的新字符串，然后在这个字符串中填充’java’和’script’，<br>最后一步是销毁原来的字符串’java’和’script’，因为这两个字符串已经没用了</p></blockquote><p>这个过程在后台发生，也是在某些旧版本浏览器(IE6)拼接字符串速度慢的原因，但浏览器后面版本已经解决了这个低效率问题。</p><h3 id="3-6-转换">3.6 转换</h3><p>把一个值转换为字符串有两种方式：<code>toString()</code>和<code>String()</code>，<span class="label label-warning">可以使用空字符串"" +某个值，将该值转换为字符串。</span></p><p><big><strong>toString()和ValueOf()</strong></big></p><p>所有的对象都继承有<code>toString()</code> 和 <code>valueOf()</code> 方法，对象到<u>字符串</u>，对象到<u>数字</u>的转换，会通过调用待转换对象的这两个方法中的一个来完成。</p><p><em><strong>第一种是:</strong></em> 使用几乎每个值都有的<code>toString()</code>方法，它的作用是返回一个表示该对象的字符串。<span class="label label-warning">undefined和null没有该方法。</span></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-literal">undefined</span>.<span class="hljs-title function_">toString</span>();<span class="hljs-comment">//Uncaught TypeError:</span><br><span class="hljs-literal">null</span>.<span class="hljs-title function_">toString</span>();<span class="hljs-comment">//Uncaught TypeError:</span><br><span class="hljs-literal">true</span>.<span class="hljs-title function_">toString</span>();<span class="hljs-comment">//&#x27;true&#x27;</span><br><span class="hljs-literal">false</span>.<span class="hljs-title function_">toString</span>();<span class="hljs-comment">//&#x27;false&#x27;</span><br><span class="hljs-string">&#x27;abc&#x27;</span>.<span class="hljs-title function_">toString</span>();<span class="hljs-comment">//&#x27;abc&#x27;</span><br><span class="hljs-number">1.23</span>.<span class="hljs-title function_">toString</span>();<span class="hljs-comment">//&#x27;1.23&#x27;</span><br>(&#123;&#125;).<span class="hljs-title function_">toString</span>();<span class="hljs-comment">//[object Object]</span><br>(&#123;<span class="hljs-attr">x</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">y</span>:<span class="hljs-number">2</span>&#125;).<span class="hljs-title function_">toString</span>()  <span class="hljs-comment">//=&gt;&quot;[object object]&quot;</span><br>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>].<span class="hljs-title function_">toString</span>();<span class="hljs-comment">//&#x27;1,2,3,4&#x27;</span><br>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()).<span class="hljs-title function_">toString</span>();<span class="hljs-comment">//&#x27;Wed Jun 22 2021 22:23:45 GMT+0800 (中国标准时间)&#x27;</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">2021</span>,<span class="hljs-number">6</span>,<span class="hljs-number">16</span>).<span class="hljs-title function_">toString</span>()  <span class="hljs-comment">//=&gt; &quot;Sat Jul 16 2021 00:00:00 GMT+0800 (中国标准时间)&quot;</span><br>/\d/.<span class="hljs-title function_">toString</span>();    <span class="hljs-comment">//=&gt;  &quot;/\\d/&quot;  或者 &quot;/\d/&quot; 浏览器不同返回也可能会不同</span><br><span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;一个错误信息&quot;</span>).<span class="hljs-title function_">toString</span>();    <span class="hljs-comment">//=&gt;  &quot;Error: 一个错误信息&quot;    </span><br>(<span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>)&#123;<span class="hljs-keyword">return</span> x&#125;).<span class="hljs-title function_">toString</span>();   <span class="hljs-comment">//=&gt;  &quot;function (x)&#123;return x&#125;&quot;     </span><br></code></pre></td></tr></table></figure><p><strong>JavaScript类型转换表:</strong></p><table><thead><tr><th>值</th><th>转换为字符串</th><th>数字</th><th>布尔值</th><th>对象</th></tr></thead><tbody><tr><td>undefined</td><td>“undefined”</td><td>NaN</td><td>false</td><td>throws ypeError</td></tr><tr><td>null</td><td>“null”</td><td>0</td><td>false</td><td>throws ypeError</td></tr><tr><td>true</td><td>“true”</td><td>1</td><td>true</td><td>new Boolea(true)</td></tr><tr><td>false</td><td>“false”</td><td>0</td><td>false</td><td>new Boolea(false)</td></tr><tr><td>“”</td><td>“”</td><td>0</td><td>false</td><td>new String(“”)</td></tr><tr><td>“1.2”</td><td>“1.2”</td><td>1.2</td><td>true</td><td>new String(“1.2”)</td></tr><tr><td>“zero”</td><td>“zero”</td><td>NaN</td><td>true</td><td>new String(“zero”)</td></tr><tr><td>0</td><td>“0”</td><td>0</td><td>false</td><td>new Number(0)</td></tr><tr><td>-0</td><td>“0”</td><td>-0</td><td>false</td><td>new Number(-0)</td></tr><tr><td>NaN</td><td>“NaN”</td><td></td><td>false</td><td>new Number(NaN)</td></tr><tr><td>Infinity</td><td>“Infinity”</td><td></td><td>true</td><td>new Number(Infinity)</td></tr><tr><td>-Infinity</td><td>“-Infinity”</td><td></td><td>true</td><td>new Number(-Infinity)</td></tr><tr><td>1(无穷大,非零)</td><td>“1”</td><td></td><td>true</td><td>new Number(1)</td></tr><tr><td>{}(任意对象)</td><td>对象本身</td><td>对象本身</td><td>true</td><td>new Object({})</td></tr><tr><td><code>[]</code>(数组)</td><td>“”</td><td>0</td><td>true</td><td>new Array()</td></tr><tr><td><code>[0]</code>(数组)</td><td>“0”</td><td>0</td><td>true</td><td>new Array()</td></tr><tr><td><code>[0,1,2]</code>(数组)</td><td>“0,1,2”</td><td>NaN</td><td>true</td><td>new Array()</td></tr><tr><td>function(){}</td><td>函数本身</td><td>NaN</td><td>true</td><td></td></tr></tbody></table><div class="note note-warning">            <p><strong>很多类定义了更多特定版本的toString()方法。</strong><br>例如，数组的 toString() 方法是将每个数组元素转换为一个字符串，并在元素之间添加逗号后合并成结果字符串。</p><p><code>函数的 toString() 方法</code>返回了这个函数的<code>实现定义</code>。实际上，这里的实现是通常是将用户定义的函数转换为 <code>JS 源代码字符串</code>。</p><p>日期 Date 的 toString() 方法返回了一个可读的日期和时间字符串。</p><p>RegExp 的 toString() 方法将RegExp对象转换为表示正则表达式直接量的字符串：</p>          </div><p><em><strong>第二种是：</strong></em> 如果对象存在任意<code>原始值</code>，它就默认将对象转换为表示它的<code>原始值</code>，如果对象是<code>复合值</code>，而且大多数对象无法真正表示为一个原始值，因此默认的<code>valueOf()</code>方法简单地返回<code>对象本身</code>，而不是返回一个原始值，更像是输出在js中存储的样子。</p><div class="note note-warning">            <p>数组、函数、和正则表达式简单的继承了这个默认方法，Array,Function,Math 和 Error 对象没有 valueOf 方法，调用这些类型的实例的valueOf( )方法只是简答返回对象本身。</p>          </div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">(&#123;&#125;).<span class="hljs-title function_">valueOf</span>();<span class="hljs-comment">//&#123;&#125;</span><br>(&#123;<span class="hljs-attr">x</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">y</span>:<span class="hljs-number">2</span>&#125;).<span class="hljs-title function_">valueOf</span>() <span class="hljs-comment">//&#123;x: 1, y: 2&#125;</span><br>(<span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>)&#123;<span class="hljs-keyword">return</span> x&#125;).<span class="hljs-title function_">valueOf</span>() <span class="hljs-comment">// ƒ (x)&#123;return x&#125;</span><br><span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;一个错误信息&quot;</span>).<span class="hljs-title function_">valueOf</span>();  <span class="hljs-comment">// Error: 一个错误信息</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">2022</span>,<span class="hljs-number">6</span>,<span class="hljs-number">16</span>).<span class="hljs-title function_">valueOf</span>() <span class="hljs-comment">// 1657900800000</span><br></code></pre></td></tr></table></figure><blockquote><p>每个JavaScript固有对象的 valueOf 方法定义不同。</p></blockquote><table><thead><tr><th>对象</th><th>返回值</th></tr></thead><tbody><tr><td>Array</td><td>数组没有valueOf方法，继承的是Object.prototype.valueOf的原始方法，返回数组本身</td></tr><tr><td>Boolean</td><td>Boolean 值。</td></tr><tr><td>Date</td><td>存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC。</td></tr><tr><td>Function</td><td>同Array</td></tr><tr><td>Number</td><td>数字值。</td></tr><tr><td>Object</td><td>对象本身。这是默认情况。</td></tr><tr><td>String</td><td>字符串值。</td></tr></tbody></table><p><code>对象</code>通过使用 toString() 和 valueOf() 方法转化为<code>原始值</code>，<u>JS语言核心的内置类首先尝试使用valueOf()，再尝试使用toString()</u>。需要注意的是，在某些特殊的场景中，JS 执行了完全不同的对象到原始值的转换。</p><blockquote><p><strong>如果传入参数是string，也就是对象到字符串的转换，经过了如下步骤：</strong><br>如果对象中有toString()方法，则调用这个方法。如果它返回一个原始值(undefined、Boolean、Number、String、BigInt、Symbol 和 null)，js将这个值转换为字符串(如果本身不是字符串的话)，并返回这个字符串结果。<br>如果对象没有toString()方法，或者toString()没有返回一个原始值，那么js会调用valueOf()方法。如果返回值是原始值，js将这个值转换为字符串，并返回字符串结果。<br>否则，js抛出一个类型错误异常。</p></blockquote><p><img src="strtobj.jpg" alt="对象到字符串的转换"></p><blockquote><p><strong>如果传入参数是number/default，也就是对象到数字的转换，经过了如下步骤：</strong><br>和上面有点不同，到数字的转换会先尝试使用valueOf()方法:<br>如果对象具有valueOf()方法，后者返回一个原始值，则js会将其转换为数字(如果需要的话)并返回这个数字。<br>否则，如果对象具有toString()方法，返回一个原始值(字符串直接量)，则js将其转换为数字类型，并返回这个数字。<br>否则，js抛出一个类型错误异常。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//改写valueOf()的原型方法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Point</span> (x, y) &#123;  <span class="hljs-comment">//自定义数据类型</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y;<br>&#125;<br><span class="hljs-title class_">Point</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">valueOf</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">//自定义Point数据类型的valueOf()方法</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;(&quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> + <span class="hljs-string">&quot;,&quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> + <span class="hljs-string">&quot;)&quot;</span>;<br>&#125;<br><span class="hljs-title class_">Point</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">//自定义Point数据类型的toString()方法</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[object Point]&quot;</span>;<br>&#125;<br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">26</span>,<span class="hljs-number">68</span>);  <span class="hljs-comment">//实例化对象</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;typeof p = &quot;</span> + p);  <span class="hljs-comment">//默认调用valueOf()方法进行类型转换</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;typeof p = &quot;</span> + p.<span class="hljs-title function_">toString</span>());  <span class="hljs-comment">//直接调用toString()方法进行类型转换</span><br><br><br><span class="hljs-comment">// 传入参数是number/default valueOf和toString在解析转化过程作用优先级</span><br><span class="hljs-keyword">var</span> exam1 = &#123; <br><span class="hljs-attr">i</span>: <span class="hljs-number">10</span>, <br><span class="hljs-attr">valueOf</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">i</span>+<span class="hljs-number">30</span>; &#125;, <br><span class="hljs-attr">toString</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">valueOf</span>()+<span class="hljs-number">10</span>; &#125; <br>&#125; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(exam1 &gt; <span class="hljs-number">20</span>); <span class="hljs-comment">// true </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(+exam1); <span class="hljs-comment">// 40 </span><br><span class="hljs-title function_">alert</span>(exam1); <span class="hljs-comment">// 50,这里chrome console.log(exam1)和alert结果不一致，</span><br><span class="hljs-comment">//console.log()传入的参数如果指向一个可变对象（数组、对象），那么它会先记录下这个引用；</span><br><span class="hljs-comment">//在你查看这个输出结果的时候，才会读取这个对象，并把相关属性和值显示出来。</span><br><br><span class="hljs-keyword">var</span> exam2 = &#123; <br><span class="hljs-attr">i</span>: <span class="hljs-number">10</span>, <br><span class="hljs-attr">toString</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;toString&#x27;</span>); <br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">i</span>; <br>&#125;, <br><span class="hljs-attr">valueOf</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;valueOf&#x27;</span>); <br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">i</span>; <br>&#125; <br>&#125; <br><span class="hljs-title function_">alert</span>(exam2);<span class="hljs-comment">// 10 toString </span><br><span class="hljs-title function_">alert</span>(+exam2); <span class="hljs-comment">// 10 valueOf </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;&#x27;</span>+exam2); <span class="hljs-comment">// 10 valueOf </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">String</span>(exam2)); <span class="hljs-comment">// 10 toString </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>(exam2)); <span class="hljs-comment">// 10 valueOf </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(exam2 == <span class="hljs-string">&#x27;10&#x27;</span>); <span class="hljs-comment">// true valueOf </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(exam2 === <span class="hljs-string">&#x27;10&#x27;</span>); <span class="hljs-comment">// false</span><br><span class="hljs-comment">//乍一看结果，大抵给人的感觉是，如果转换为字符串时调用toString方法，</span><br><span class="hljs-comment">//如果是转换为数值时则调用valueOf方法，但其中有两个很不和谐。</span><br><span class="hljs-comment">//一个是alert(&#x27;&#x27;+bbb)，字符串合拼应该是调用toString方法……</span><br><span class="hljs-comment">//另一个我们暂时可以理解为===操作符不进行隐式转换，因此不调用它们。</span><br><br><span class="hljs-comment">//进一步进行测试</span><br><span class="hljs-keyword">var</span> exam3 = &#123; <br><span class="hljs-attr">i</span>: <span class="hljs-number">10</span>, <br><span class="hljs-attr">toString</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;toString&#x27;</span>); <br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">i</span>; <br>&#125; <br>&#125; <br><span class="hljs-title function_">alert</span>(exam3);<span class="hljs-comment">// 10 toString </span><br><span class="hljs-title function_">alert</span>(+exam3); <span class="hljs-comment">// 10 toString </span><br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;&#x27;</span>+exam3); <span class="hljs-comment">// 10 toString </span><br><span class="hljs-title function_">alert</span>(<span class="hljs-title class_">String</span>(exam3)); <span class="hljs-comment">// 10 toString </span><br><span class="hljs-title function_">alert</span>(<span class="hljs-title class_">Number</span>(exam3)); <span class="hljs-comment">// 10 toString </span><br><span class="hljs-title function_">alert</span>(exam3 == <span class="hljs-string">&#x27;10&#x27;</span>); <span class="hljs-comment">// true toString </span><br><span class="hljs-comment">//再看valueOf。 </span><br><span class="hljs-keyword">var</span> exam4 = &#123; <br><span class="hljs-attr">i</span>: <span class="hljs-number">10</span>, <br><span class="hljs-attr">valueOf</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;valueOf&#x27;</span>); <br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">i</span>; <br>&#125; <br>&#125; <br><span class="hljs-title function_">alert</span>(exam4);<span class="hljs-comment">// [object Object] </span><br><span class="hljs-title function_">alert</span>(+exam4); <span class="hljs-comment">// 10 valueOf </span><br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;&#x27;</span>+exam4); <span class="hljs-comment">// 10 valueOf </span><br><span class="hljs-title function_">alert</span>(<span class="hljs-title class_">String</span>(exam4)); <span class="hljs-comment">// [object Object] </span><br><span class="hljs-title function_">alert</span>(<span class="hljs-title class_">Number</span>(exam4)); <span class="hljs-comment">// 10 valueOf </span><br><span class="hljs-title function_">alert</span>(exam4 == <span class="hljs-string">&#x27;10&#x27;</span>); <span class="hljs-comment">// true valueOf </span><br><span class="hljs-comment">//没有像上面toString那样统一规整。对于那个[object Object]，</span><br><span class="hljs-comment">//估计是从Object那里继承过来的，我们再去掉它看看。 </span><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span> = <span class="hljs-literal">null</span>; <br><span class="hljs-keyword">var</span> exam5 = &#123; <br><span class="hljs-attr">i</span>: <span class="hljs-number">10</span>, <br><span class="hljs-attr">valueOf</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;valueOf&#x27;</span>); <br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">i</span>; <br>&#125; <br>&#125; <br><span class="hljs-title function_">alert</span>(exam5);<span class="hljs-comment">// 10 valueOf </span><br><span class="hljs-title function_">alert</span>(+exam5); <span class="hljs-comment">// 10 valueOf </span><br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;&#x27;</span>+exam5); <span class="hljs-comment">// 10 valueOf </span><br><span class="hljs-title function_">alert</span>(<span class="hljs-title class_">String</span>(exam5)); <span class="hljs-comment">// 10 valueOf </span><br><span class="hljs-title function_">alert</span>(<span class="hljs-title class_">Number</span>(exam5)); <span class="hljs-comment">// 10 valueOf </span><br><span class="hljs-title function_">alert</span>(exam5 == <span class="hljs-string">&#x27;10&#x27;</span>); <span class="hljs-comment">// true valueOf </span><br><br><span class="hljs-comment">//总结,向上面的例子如果只重写了toString，对象转换时会无视valueOf的存在来进行转换。</span><br><span class="hljs-comment">//但是，如果只重写了valueOf方法，在要转换为字符串的时候会优先考虑valueOf方法，</span><br><span class="hljs-comment">//然后在符合toString规则的地方仍使用toString。</span><br><span class="hljs-comment">//除非向上面那样将toString重置为空，在不能调用toString的情况下，才会用valueOf</span><br></code></pre></td></tr></table></figure><span class="label label-warning">注意：<br> 1、对于所有`非日期对象`来说，对象到原始值的转换基本上是`对象到数字`的转换。<br> 当调用 valueOf() 方法时，大多数原生对象都会返回对象本身。因此 toString() 方法使用得更频繁。<br> 2、关于 `Date 对象`的注意事项:在转换为原始值时，对象立即使用 `toString() 方法转换为字符串`。<br> 3、普通的 JS 对象，`{}`或 `new object()`，通常被转换成 [object Object]。<br> 4、数组通过将它的元素与“,”分隔符连接转换为。例如 [1,3，"four"] 被转换成" 1,3,four"。</span><div class="note note-success">            <p><strong>日期对象的特殊情况：</strong><br><code>日期对象</code>在原型里自定义了<code>toString()</code>，即<code>Date.prototype.toString()</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> date = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>date.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// =&gt; &#x27;Fri Jun 24 2021 10:48:13 GMT+0800 (中国标准时间)&#x27;</span><br></code></pre></td></tr></table></figure><p>Date 对象覆盖了从 Object 继承来的<code>Object.prototype.toString()</code> 方法。Date的<code>toString() </code>方法总是返回一个美式英语日期格式的字符串。当一个<code>日期对象</code>被用来作为<code>文本值</code>或用来进行<code>字符串连接</code>时，<code>toString()</code> 方法会被自动调用。</p><p>“<code>+</code>” 和 “<code>==</code>” 应用的<code>对象到原始值</code>的转换包含日期对象的一种特殊情形。</p><p>日期类是JavaScript语言核心中<code>唯一</code>的预先定义类型，它定义了有意义的向字符串和数字类型的转换。</p><p>对于所有非日期的对象来说， 对象到原始值的转换基本上是对象到数字的转换（<code>首先调用valueOf()</code>) , 日期对象则使用对象到字符串的转换模式，然而，这里的转换和上文讲述的井不完全一致：通过<code>valueOf()</code>或<code>toString()</code>返回的原始值将被直接使用，而不会被强制转换为<code>数字</code>或<code>字符串</code>。</p><p>和&quot;<code>==</code>&quot; 一样， ＂<code>＜</code>” 运算符以及其他关系运算符也会做对象到原始值的转换， 但要<u>除去日期对象的特殊情形：任何对象都会<strong>首先尝试调用valueOf()</strong>, <strong>然后调用toString()</strong></u>。不管得到的原始值是否直接使用，它都不会进一步被转换为数字或字符串。</p><p>“<code>+</code>”、 “<code>==</code>”、 “<code>!=</code>” 和<code>关系运算符</code>是唯一执行这种特殊的字符串到原始值的转换方式的运算符。 其他运算符到特定类型的转换都很明确，而且对日期对象来讲也没有特殊情况。 例如 &quot; <code>-</code>  (减号）运算符把它的两个操作数都转换为数字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();    <span class="hljs-comment">// 当前时间</span><br><span class="hljs-keyword">typeof</span> (now + <span class="hljs-number">1</span>);         <span class="hljs-comment">// &quot;string&quot;</span><br><span class="hljs-keyword">typeof</span> (now - <span class="hljs-number">1</span>)；       <span class="hljs-comment">// &quot;number&quot;</span><br>now == now. <span class="hljs-title function_">toString</span>()； <span class="hljs-comment">// true</span><br>now &gt; (now -<span class="hljs-number">1</span>)；         <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();  <br>now + <span class="hljs-number">1</span><br><span class="hljs-comment">//&#x27;Fri Oct 01 2021 10:58:55 GMT+0800 (中国标准时间)1&#x27;</span><br>now - <span class="hljs-number">1</span><br><span class="hljs-comment">// 1633057135763</span><br><br></code></pre></td></tr></table></figure><p><strong>字符串连接符与算术隐式转换规则混淆:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span> + <span class="hljs-literal">true</span>);      <span class="hljs-comment">//2</span><br><span class="hljs-comment">//+做为算术运算符会把其他数据类型调用Number()转成数字然后做加法运算,布尔值true会被转换数字 1;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span> + <span class="hljs-string">&quot;true&quot;</span>);        <span class="hljs-comment">//&quot;1true&quot;,</span><br><span class="hljs-comment">//+两边有一边是字符串，那这个+就是字符串连接符，它会把其他数据类型调用String()方法转成字符串然后拼接；</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span> + <span class="hljs-literal">undefined</span>);     <span class="hljs-comment">//NaN,undefined会被转换为 NaN，</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span> + <span class="hljs-literal">null</span>);      <span class="hljs-comment">//1,null会转换为数字 0</span><br><br><span class="hljs-comment">//大坑</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span> ( [] == <span class="hljs-number">0</span> );        <span class="hljs-comment">//true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span> ( ! [] == <span class="hljs-number">0</span> );      <span class="hljs-comment">//true</span><br><span class="hljs-comment">//神坑</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span> ( [] == ! [] );     <span class="hljs-comment">//true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span> ( [] == [] );       <span class="hljs-comment">//false</span><br><span class="hljs-comment">//史诗级坑</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123;&#125; == !&#123;&#125;);     <span class="hljs-comment">//false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123;&#125; == &#123;&#125;);      <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><p><code>[]</code> 与 <code>0</code>比较：<br>（1）[].valueOf().toString() 得到空字符串<br>（2）Number(“”) == 0 成立</p><p><code>![] </code>与 <code>0</code>比较：<br>（1）逻辑非优先级高于关系运算符 ![] = false (空数组转布尔得到true，然后取反得到false)<br>（2）false == 0 成立</p><p><code>[]</code> 与 <code>![]</code>比较：<br>（1） [].valueOf().toString() 得到空字符串 “”<br>（2） ![] = false<br>（3） Number(“”) == Number(false) 成立 都是0</p><p><code>[]</code> 与 <code>[]</code>比较：<br>引用类型数据存在<code>堆内存</code>中，<code>栈内存</code>中存储的是<code>地址</code>，所以他们的结果是false</p><p><code>{}</code> 与 <code>!{}</code>比较：<br>（1） {}.valueOf().toString() 得到字符串’[object Object]’<br>（2） !{} = false<br>（3） Number(‘[object Object]’) == Number(false) 不成立，因为转换到最后 是NaN 和 0比较，所以结果为 false</p><p><code>{}</code> 与 <code>{}</code>比较：<br>引用类型数据存在堆内存中，栈内存中存储的是地址，所以他们的结果是false</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;&#125;+[]<br><span class="hljs-comment">//0</span><br></code></pre></td></tr></table></figure><p>空对象加空数组就不一样了，加号运算符的定义是这样的：如果其中一个是字符串，另一个也会被转换为字符串，否则两个运算数都被转换为数字。 而同时，javascript有这样的特性，如果{}既可以被认为是代码块，又可以被认为是对象字面量，那么js会把他当做代码块来看待。<br>这就很好解释了，{}被当做了代码块，只有+[]，根据加法的定义，被转换为0，就得到了结果。</p><p><strong>{}和[]的 valueOf() 和 toString() 的结果是什么？</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">([]).<span class="hljs-title function_">valueOf</span>() <span class="hljs-comment">//[]</span><br>([]).<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// &#x27;&#x27;</span><br>(&#123;&#125;).<span class="hljs-title function_">valueOf</span>()<span class="hljs-comment">//&#123;&#125;</span><br>(&#123;&#125;).<span class="hljs-title function_">toString</span>()<span class="hljs-comment">//&#x27;[object Object]&#x27;</span><br></code></pre></td></tr></table></figure>          </div><p><br><big><strong>String()</strong></big></p><p>在不知道要转换的值是不是undefined或null时，可以使用转型函数String()，转型函数String()遵循下列规则：</p><blockquote><ol><li>如果值是null，则返回’null’；如果值是undefined，则返回’undefined’；</li><li>如果值不是null或undefined，则调用toString()方法并返回原始类型值；</li><li>若使用toString()方法返回的是对象，则再调用valueOf()方法返回原始类型值，若使用valueOf()方法返回的是对象，会报错。</li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">String</span>(&#123;<span class="hljs-attr">toString</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>  &#125;<br>&#125;)<span class="hljs-comment">//&quot;3&quot;</span><br><br><span class="hljs-title class_">String</span>(&#123;<span class="hljs-attr">valueOf</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  &#125;<br>&#125;)<span class="hljs-comment">// [object,object]</span><br><br><br><span class="hljs-title class_">String</span>(&#123;<br>  <span class="hljs-attr">valueOf</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  &#125;,<br>  <span class="hljs-attr">toString</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>  &#125;<br>&#125;)<span class="hljs-comment">//  &quot;3&quot;</span><br><span class="hljs-comment">//之所以得到这个结果，调用toString()方法并返回原始类型值,如果toString不存在，则会调用valueOf</span><br><br></code></pre></td></tr></table></figure><h3 id="3-7-函数或方法">3.7 函数或方法</h3><p>除了length属性之外，JavaScript还提供了操作字符串的丰富API：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><br><span class="hljs-comment">//截取字符串</span><br>s.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>,<span class="hljs-number">4</span>); <span class="hljs-comment">//&#x27;ell&#x27;,第2-4个字符</span><br>s.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>,<span class="hljs-number">4</span>)<span class="hljs-comment">//&#x27;ell&#x27;,同上</span><br>s.<span class="hljs-title function_">slice</span>(-<span class="hljs-number">3</span>)<span class="hljs-comment">//&#x27;rld&#x27;,最后三个字符</span><br>s.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;,&quot;</span>)<span class="hljs-comment">//[&#x27;hello&#x27;, &#x27;world&#x27;] 从界定符处拆开</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-comment">/*</span><br><span class="hljs-comment">  line1</span><br><span class="hljs-comment">  line2</span><br><span class="hljs-comment">  line3</span><br><span class="hljs-comment">  */</span>&#125;).<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;\n&#x27;</span>).<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>  <span class="hljs-comment">//&#x27;  line1\n  line2\n  line3&#x27;</span><br><br><span class="hljs-comment">// 检索字符串</span><br>s.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;l&#x27;</span>)<span class="hljs-comment">//2,第一个字母l的位置</span><br>s.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-number">4</span>)<span class="hljs-comment">//10,位置4后面第一个l的位置，包含位置4</span><br>s.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-number">3</span>)<span class="hljs-comment">//3,位置3后面第一个l的位置 </span><br>s.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;so&#x27;</span>)<span class="hljs-comment">//-1,字符串中并不包含字串&#x27;so&#x27;</span><br>s.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-string">&#x27;l&#x27;</span>)<span class="hljs-comment">//10,字符串中最后一个&#x27;l&#x27;的位置</span><br><br><span class="hljs-comment">//es6及之后版本的布尔值搜索函数</span><br>s.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<span class="hljs-comment">//true,字符串以这些字符开头</span><br>s.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;!&#x27;</span>)<span class="hljs-comment">//true,字符串以这些字符结尾</span><br>s.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;or&#x27;</span>)<span class="hljs-comment">//true,s包含字串‘or’</span><br><br><span class="hljs-comment">//创建字符串的修改</span><br>s.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;llo&#x27;</span>,<span class="hljs-string">&#x27;ya&#x27;</span>)<span class="hljs-comment">//&#x27;heya, world!&#x27;,</span><br>s.<span class="hljs-title function_">toLowerCase</span>()<span class="hljs-comment">//&#x27;hello, world!&#x27;</span><br>s.<span class="hljs-title function_">toUpperCase</span>()<span class="hljs-comment">//&#x27;HELLO, WORLD!&#x27;</span><br>s.<span class="hljs-title function_">normalize</span>()<span class="hljs-comment">//es6新增，Unicode NFC归一化</span><br>s.<span class="hljs-title function_">normalize</span>(<span class="hljs-string">&#x27;NFD&#x27;</span>)<span class="hljs-comment">//&#x27;NFD归一化&#x27;，还有‘NFKC’和‘NFKD’</span><br><br><span class="hljs-comment">//访问字符串中的个别（16位值）字符</span><br>s.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>)<span class="hljs-comment">//&#x27;H&#x27;,第一个字符</span><br>s.<span class="hljs-title function_">charAt</span>(s.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>)<span class="hljs-comment">//&#x27;!&#x27;,最后一个字符</span><br>s.<span class="hljs-title function_">charCodeAt</span>(<span class="hljs-string">&#x27;0&#x27;</span>)<span class="hljs-comment">//104,指定位置的16位数值</span><br>s.<span class="hljs-title function_">codePointAt</span>(<span class="hljs-string">&#x27;0&#x27;</span>)<span class="hljs-comment">//104,适用于码点大于16位的情形</span><br><br><span class="hljs-comment">//ES2017新增的字符串填充函数</span><br><span class="hljs-string">&#x27;X&#x27;</span>.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">3</span>)<span class="hljs-comment">//&#x27;  X&#x27;,左侧添加空格使字符串长度变成3</span><br><span class="hljs-string">&#x27;X&#x27;</span>.<span class="hljs-title function_">padEnd</span>(<span class="hljs-number">3</span>)<span class="hljs-comment">//&#x27;X  &#x27;,右侧添加空格，是字符串长度变成3</span><br><span class="hljs-string">&#x27;X&#x27;</span>.<span class="hljs-title function_">padStart</span>(<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;*&#x27;</span>)<span class="hljs-comment">//&#x27;**X&#x27;,左侧添加*使字符串长度变成3</span><br><span class="hljs-string">&#x27;X&#x27;</span>.<span class="hljs-title function_">padEnd</span>(<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;*&#x27;</span>)<span class="hljs-comment">//&#x27;X**&#x27;,右侧添加*使字符串长度变成3</span><br><br><span class="hljs-comment">//删除空格函数，trim()是es5就有点，其他是es2019新增的</span><br><span class="hljs-string">&#x27; test &#x27;</span>.<span class="hljs-title function_">trim</span>()<span class="hljs-comment">//&#x27;test&#x27;,删除开头末尾空格，不会删除字符串之间的空格</span><br><span class="hljs-string">&#x27; test &#x27;</span>.<span class="hljs-title function_">trimStart</span>()<span class="hljs-comment">//&#x27;test &#x27;,删除左侧空格，也叫trimLeft()</span><br><span class="hljs-string">&#x27; test &#x27;</span>.<span class="hljs-title function_">trimEnd</span>()<span class="hljs-comment">//&#x27; test&#x27;，删除右侧空格，也叫trimRight()</span><br><br><span class="hljs-comment">//未分类字符串方法</span><br>s.<span class="hljs-title function_">concat</span>(<span class="hljs-string">&#x27;!&#x27;</span>)<span class="hljs-comment">//&#x27;hello, world!!&#x27;,可以用&#x27;+&#x27;字符串代替</span><br><span class="hljs-string">&#x27;&lt;&gt;&#x27;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">5</span>)<span class="hljs-comment">//&#x27;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&#x27;,拼接n次，es6新增</span><br></code></pre></td></tr></table></figure><p>JavaScript中的字符串是不可修改的。像replace()和toUpperCase()这样的方法都返回新字符串，它们并不会修改调用它们的字符串。<br>字符串也可以被当成只读数组，使用方括号而非charAt()方法访问字符串中个别的字符（16位值）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>s[<span class="hljs-number">0</span>]<span class="hljs-comment">//&#x27;h&#x27;</span><br>s[s.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>]<span class="hljs-comment">//&#x27;!&#x27;</span><br></code></pre></td></tr></table></figure><p><big><strong>normalize()方法</strong></big><br>normalize() 方法会按照指定的一种 Unicode 正规形式将当前字符串正规化。<br>多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。一种是直接提供带重音符号的字符，比如Ǒ（\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（\u004F）和ˇ（\u030C）合成Ǒ（\u004F\u030C）。<br>这两种表示方法，在视觉和语义上都等价，但是 JavaScript 不能识别。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;\u01D1&#x27;</span>===<span class="hljs-string">&#x27;\u004F\u030C&#x27;</span> <span class="hljs-comment">//false</span><br><br><span class="hljs-string">&#x27;\u01D1&#x27;</span>.<span class="hljs-property">length</span> <span class="hljs-comment">// 1</span><br><span class="hljs-string">&#x27;\u004F\u030C&#x27;</span>.<span class="hljs-property">length</span> <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>ES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;\u01D1&#x27;</span>.<span class="hljs-title function_">normalize</span>() === <span class="hljs-string">&#x27;\u004F\u030C&#x27;</span>.<span class="hljs-title function_">normalize</span>()<br><span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>normalize方法可以接受一个参数来指定normalize的方式，参数的四个可选值如下：</p><blockquote><p>NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。<br>NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。<br>NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。）<br>NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;\u004F\u030C&#x27;</span>.<span class="hljs-title function_">normalize</span>(<span class="hljs-string">&#x27;NFC&#x27;</span>).<span class="hljs-property">length</span> <span class="hljs-comment">// 1</span><br><span class="hljs-string">&#x27;\u004F\u030C&#x27;</span>.<span class="hljs-title function_">normalize</span>(<span class="hljs-string">&#x27;NFD&#x27;</span>).<span class="hljs-property">length</span> <span class="hljs-comment">// 2</span><br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;\u1E9B\u0323&quot;</span>;<br>str.<span class="hljs-title function_">normalize</span>(<span class="hljs-string">&quot;NFC&quot;</span>); <span class="hljs-comment">// ẛ̣</span><br>str.<span class="hljs-title function_">normalize</span>(); <span class="hljs-comment">// ẛ̣</span><br>str.<span class="hljs-title function_">normalize</span>(<span class="hljs-string">&quot;NFD&quot;</span>); <span class="hljs-comment">//ẛ̣ </span><br>str.<span class="hljs-title function_">normalize</span>(<span class="hljs-string">&quot;NFKC&quot;</span>); <span class="hljs-comment">//ṩ</span><br>str.<span class="hljs-title function_">normalize</span>(<span class="hljs-string">&quot;NFKD&quot;</span>); <span class="hljs-comment">//ṩ</span><br></code></pre></td></tr></table></figure><p>normalize方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。</p><h3 id="3-8-模板字面量">3.8 模板字面量</h3><p>ES6引入了一种新型的字符串字面量，模板字面量（Template Literal）是一种能够嵌入表达式的格式化字符串，有别于普通字符串，它使用反引号（<code>`</code>）包裹字符序列，而不是双引号或单引号。模板字面量包含特定形式的占位符（<code>$&#123;expression&#125;</code>），合法的表达式（expression）可以是<code>变量</code>、<code>算术</code>或<code>函数调用</code>，甚至还可以是<code>模板字面量</code>。</p><p>许多开发者认为模板是一段可复用的，可重绘的文本，就像大多数模板引擎（Mustache，Handlebars，等等）那样。ES6中使用的 <code>模板</code> 一词也暗含类似的表达，就像一种声明可以被重绘的内联模板字面量的方法，但这种表达并不准确。它更准确的名称应该是：<code>插值型字符串字面量</code>（或者略称为 <code>插值型字面量</code>）。</p><p>在ES6引入模板字面量后，就能避免用若干个加号来实现字符串拼接，而改用更为优雅的语法来替代，下面用新旧两种方式分别来组合字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//ES6之前</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Kyle&quot;</span>;<br><span class="hljs-keyword">var</span> greeting = <span class="hljs-string">&quot;Hello &quot;</span> + name + <span class="hljs-string">&quot;!&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( greeting );            <span class="hljs-comment">// &quot;Hello Kyle!&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-keyword">typeof</span> greeting );        <span class="hljs-comment">// &quot;string&quot;</span><br><br><span class="hljs-comment">//ES6及之后</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Kyle&quot;</span>;<br><span class="hljs-keyword">var</span> greeting = <span class="hljs-string">`Hello <span class="hljs-subst">$&#123;name&#125;</span>!`</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( greeting );            <span class="hljs-comment">// &quot;Hello Kyle!&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-keyword">typeof</span> greeting );        <span class="hljs-comment">// &quot;string&quot;</span><br></code></pre></td></tr></table></figure><p>如上所示，我们在一系列被翻译为字符串字面量的字符周围使用了<code> `..`</code> ，但是<code>$&#123;..&#125;</code>形式中的任何表达式都将立即内联地被解析和求值。称呼这样的解析和求值的名词就是 <code>插值</code>（interpolation）（比模板要更准确）。</p><p>被插值的字符串字面量表达式的结果只是一个老式的普通字符串，赋值给变量greeting。</p><div class="note note-warning">            <p><code>typeof greeting == &quot;string&quot;</code>展示了为什么不将这些实体考虑为特殊的模板值很重要，因为你不能将这种字面量的未求值形式赋值给某些东西并复用它。<code>${..}</code> 插值型字符串字面量在某种意义上更像是IIFE（<u>立即调用函数表达式</u><sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="IIFE https://developer.mozilla.org/zh-CN/docs/Glossary/IIFE">[3]</span></a></sup>），因为它自动内联地被求值。<code>${..}</code> 插值型字符串字面量的结果只不过是一个简单的字符串。</p>          </div><p>这不仅仅是一种新的字符串字面量语法，因为插值型字符串字面量可以包含任意JavaScript表达式。反引号中字符串字面量最终值的计算，涉及对其中包含的所有表达式求值、将这些表达式的值转换为字符串，然后再把这些字符串与反引号中的字面量组合：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> name=<span class="hljs-string">&#x27;Bill&#x27;</span>;<br><span class="hljs-keyword">let</span> greeting = <span class="hljs-string">`hello <span class="hljs-subst">$&#123; name &#125;</span>.`</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting); <span class="hljs-comment">//hello Bill</span><br></code></pre></td></tr></table></figure><p>位于<code>$&#123;..&#125;</code>之间的内容都被当作JavaScript表达式来解释。而位于这对花括号之外的则是常规字符串字面量。括号内的表达式会被求值，然后转换为字符串并插入模板中，替换<code>$&#123;..&#125;</code>中的所有内容。</p><p>字符串字面量可以包含任意数量的表达式，可以包含任何常规字符串中可以出现的转义字符，也可以跨任意多行而无须特殊转义。下面的字符串字面量包含4个JavaScript表达式、1个Unicode转义序列和至少4个换行符（表达式的值也可能包含换行符）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> filename = <span class="hljs-string">&#x27;文件名&#x27;</span>;<br><span class="hljs-keyword">let</span> linenumber = <span class="hljs-string">&#x27;123&#x27;</span><br><span class="hljs-keyword">let</span> exception = &#123;<br>  <span class="hljs-attr">message</span>:<span class="hljs-string">&#x27;The Error Message&#x27;</span>,<br>  <span class="hljs-attr">stack</span>:<span class="hljs-string">&#x27;None Explor&#x27;</span><br>&#125;<br><span class="hljs-keyword">let</span> errorMessage = <span class="hljs-string">`\</span><br><span class="hljs-string">\u2718 Test failure at <span class="hljs-subst">$&#123;filename&#125;</span>:<span class="hljs-subst">$&#123;linenumber&#125;</span>:</span><br><span class="hljs-string"><span class="hljs-subst">$&#123;exception.message&#125;</span></span><br><span class="hljs-string">Stack trace:</span><br><span class="hljs-string"><span class="hljs-subst">$&#123;exception.stack&#125;</span></span><br><span class="hljs-string">`</span>;<br><span class="hljs-comment">//这里第一行末尾的反斜杠转义了第一个换行符，</span><br><span class="hljs-comment">//因此最终字符串的第一个字符是Unicode字符✘（\u2718）而非换行符。</span><br><br><span class="hljs-comment">//✘ Test failure at 文件名:123:</span><br><span class="hljs-comment">//The Error Message</span><br><span class="hljs-comment">//Stack trace:</span><br><span class="hljs-comment">//None Explor</span><br><br><span class="hljs-comment">//插值型字符串字面量的一个真正的好处是他们允许被分割为多行：</span><br><span class="hljs-keyword">var</span> text =<br><span class="hljs-string">`Now is the time for all good men</span><br><span class="hljs-string">to come to the aid of their</span><br><span class="hljs-string">country!`</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( text );<br><span class="hljs-comment">// Now is the time for all good men</span><br><span class="hljs-comment">// to come to the aid of their</span><br><span class="hljs-comment">// country!</span><br></code></pre></td></tr></table></figure><p>除非在字面量值中作为明确的转义序列出现，回车字符\r（编码点U+000D）的值或者回车+换行序列\r\n（编码点U+000D和U+000A）的值都会被泛化为一个换行字符\n（编码点U+000A）。但不要担心；这种泛化很少见而且很可能仅会在你将文本拷贝粘贴到JS文件中时才会发生。</p><p><big><strong>插值表达式</strong></big></p><p>在一个插值型字符串字面量中，任何合法的表达式都被允许出现在<code>$&#123;..&#125;内部</code>，包括<code>函数调用</code>，<code>内联函数表达式</code>调用，甚至是另一个<code>插值型字符串字面量</code>！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">upper</span>(<span class="hljs-params">s</span>)&#123;<br>  <span class="hljs-keyword">return</span> s.<span class="hljs-title function_">toUpperCase</span>();<br>&#125;<br><br><span class="hljs-keyword">let</span> who = <span class="hljs-string">&#x27;reader&#x27;</span>;<br><span class="hljs-keyword">let</span> text=<br><span class="hljs-string">`A very <span class="hljs-subst">$&#123;upper(<span class="hljs-string">&#x27;warm&#x27;</span>)&#125;</span> welcome</span><br><span class="hljs-string">to your <span class="hljs-subst">$&#123;upper( <span class="hljs-string">`<span class="hljs-subst">$&#123;who&#125;</span>s`</span> ) &#125;</span>!`</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(text);<br><span class="hljs-comment">//A very WARM welcome</span><br><span class="hljs-comment">//to your READERS!</span><br><br><span class="hljs-comment">//chrome浏览器给属性自动添加前缀</span><br><span class="hljs-keyword">let</span> attr = <span class="hljs-string">&#x27;border-radius&#x27;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">isChrome</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<span class="hljs-comment">//...省略了浏览器嗅探逻辑</span><br>attr = <span class="hljs-string">`<span class="hljs-subst">$&#123;isChrome() ? <span class="hljs-string">`-webkit-<span class="hljs-subst">$&#123;attr&#125;</span>`</span> : attr&#125;</span>`</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(attr);<br><span class="hljs-comment">//-webkit-border-radius</span><br></code></pre></td></tr></table></figure><p>当我们组合变量who与字符串s时， 相对于<code>who + &quot;s&quot;</code>，这里的内部插值型字符串字面量<code>`$&#123;who&#125;s`</code> 更方便一些。<code>-webkit-$&#123;attr&#125;</code>也是同理。</p><p><big><strong>表达式作用域</strong></big></p><p>在<code>$&#123;..&#125;</code>中的变量，它的作用域和定义字符串字面量时所处的位置有关，而不是调用时的位置。以下面代码为例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> scope = <span class="hljs-string">&quot;global&quot;</span>;     <span class="hljs-comment">//全局变量</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer1</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> scope = <span class="hljs-string">&quot;outer&quot;</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params">str</span>) &#123;<br>    <span class="hljs-keyword">let</span> scope = <span class="hljs-string">&quot;inner&quot;</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);<br>  &#125;<br>  <span class="hljs-title function_">inner</span>(<span class="hljs-string">`current <span class="hljs-subst">$&#123;scope&#125;</span>`</span>);<br>&#125;<br><span class="hljs-title function_">outer1</span>();             　　<span class="hljs-comment">//&quot;current outer&quot;</span><br></code></pre></td></tr></table></figure><p>有3个同名的scope变量，分别定义在全局作用域、outer1()函数和inner()函数中，字符串字面量作为一个实参传递给inner()函数，最后在inner()函数中把字符串字面量输出到控制台。</p><p>根据前面的作用域规则可知，得到的结果是“current outer”。<br>如果字符串字面量所处的作用域中没有该变量，那么就会沿着作用域链向上搜索，直到全局作用域为止。<br>在下面的代码中，注释了outer2()函数中的scope变量，得到的结果为“current global”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> scope = <span class="hljs-string">&quot;global&quot;</span>;     <span class="hljs-comment">//全局变量</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer2</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">//let scope = &quot;outer&quot;;</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params">str</span>) &#123;<br>    <span class="hljs-keyword">let</span> scope = <span class="hljs-string">&quot;inner&quot;</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);<br>  &#125;<br>  <span class="hljs-title function_">inner</span>(<span class="hljs-string">`current <span class="hljs-subst">$&#123;scope&#125;</span>`</span>);<br>&#125;<br><span class="hljs-title function_">outer2</span>();             　　<span class="hljs-comment">//&quot;current global&quot;</span><br></code></pre></td></tr></table></figure><p>再考虑如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">str</span>) &#123;<br>    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;foo&quot;</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( str );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;bar&quot;</span>;<br>    <span class="hljs-title function_">foo</span>( <span class="hljs-string">`Hello from <span class="hljs-subst">$&#123;name&#125;</span>!`</span> );<br>&#125;<br><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;global&quot;</span>;<br><br><span class="hljs-title function_">bar</span>();       <span class="hljs-comment">//Hello from bar!</span><br></code></pre></td></tr></table></figure><p>在函数bar()内部，字符串字面量<code>..</code> 被表达的那一刻，可供它查找的作用域发现变量的name的值为&quot;bar&quot;。既不是全局的name也不是foo(…)的name。</p><p>换句话说，一个插值型字符串字面量在它出现的地方是它的词法作用域，而不是其他任何方式的动态作用域。</p><p><big><strong>标签模板（标签型模板字面量）</strong></big><br>模板字面量虽然强大，但也有它的局限性，例如下面两点：</p><blockquote><p>（1）有可能会遭受XSS（跨站脚本攻击）攻击，因为无法转义HTML中的特殊字符（例如“&lt;”、“&gt;”等）。<br>（2）不能替代模板引擎（例如Mustache、Handlebars等），因为无法在占位符中使用if、while等语句。</p></blockquote><p>为了解决上述问题，ES6引入了标签模板（Tagged Template）。标签模板并不是模板，而是一种特殊方式的函数调用，如下所示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">func<span class="hljs-string">`&lt;p&gt;<span class="hljs-subst">$&#123;name&#125;</span>&lt;/p&gt;&lt;p&gt;<span class="hljs-subst">$&#123;age&#125;</span>&lt;/p&gt;`</span><br></code></pre></td></tr></table></figure><p>调用func()函数的时候省略了圆括号，函数名后面直接跟模板字面量，这就是标签模板的调用方式。它一般会包含两个参数，第一个是由没有被替换的部分组成的数组，第二个是剩余参数，包含了所有占位符中的计算结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//eg1</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">literals, ...substitutions</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(literals);          <span class="hljs-comment">//[&quot;&lt;p&gt;&quot;, &quot;&lt;/p&gt;&lt;p&gt;&quot;, &quot;&lt;/p&gt;&quot;, raw]</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(substitutions);     <span class="hljs-comment">//[&quot;strick&quot;, 29]</span><br>&#125;<br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;strick&quot;</span>,<br>  age = <span class="hljs-number">29</span>;<br>func<span class="hljs-string">`&lt;p&gt;<span class="hljs-subst">$&#123;name&#125;</span>&lt;/p&gt;&lt;p&gt;<span class="hljs-subst">$&#123;age&#125;</span>&lt;/p&gt;`</span>;<br><br><span class="hljs-comment">//eg2</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">strings, ...values</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( strings );<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( values );<br>&#125;<br><span class="hljs-keyword">var</span> desc = <span class="hljs-string">&quot;awesome&quot;</span>;<br>foo<span class="hljs-string">`Everything is <span class="hljs-subst">$&#123;desc&#125;</span>!`</span>;<br><span class="hljs-comment">// [ &#x27;Everything is &#x27;, &#x27;!&#x27;, raw]</span><br><span class="hljs-comment">// [ &quot;awesome&quot; ]</span><br></code></pre></td></tr></table></figure><p>我们对上面的代码进行解析，<code>函数名`...`</code>，实质上是一种不需要( … )的特殊函数调用。<code>标签</code> —— 在字符串字面量<code>..</code> 之前的<code>函数名</code>（func、foo）部分 —— 是一个应当被调用的函数的值。实际上，它可以是返回函数的任何表达式，甚至是一个返回另一个函数的函数调用，就像：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">strings, ...values</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( strings );<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( values );<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> desc = <span class="hljs-string">&quot;awesome&quot;</span>;<br><span class="hljs-title function_">bar</span>()<span class="hljs-string">`Everything is <span class="hljs-subst">$&#123;desc&#125;</span>!`</span>;<br><span class="hljs-comment">// [ &quot;Everything is &quot;, &quot;!&quot;]</span><br><span class="hljs-comment">// [ &quot;awesome&quot; ]</span><br></code></pre></td></tr></table></figure><p>但当作为一个字符串字面量的标签时，函数foo(…)被传入了什么？<br>第一个参数值 —— 我们称它为strings —— 是一个所有普通字符串的数组（所有被插值的表达式<code>$&#123;..&#125;</code>之间的东西）。我们在strings数组中得到两个值：“Everything is “和”!”。</p><p>strings后面的参数可以单独命名,但我们通常使用<code>...收集/剩余操作符</code>将所有后续的参数值收集到一个称为values的数组中。</p><p>被收集进values数组中的参数值，就是在字符串字面量中已经被求过值的<code>$&#123;..&#125;</code>插值表达式的结果。</p><p>一个标签型字符串字面量像是一个在插值表达式被求值之后，但是在最终的字符串被编译之前的处理步骤，允许你在从字面量中产生字符串的过程中进行更多的控制。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">tag</span>(<span class="hljs-params">strings, ...values</span>) &#123;<br>    <span class="hljs-keyword">return</span> strings.<span class="hljs-title function_">reduce</span>( <span class="hljs-keyword">function</span>(<span class="hljs-params">s,v,idx</span>)&#123;<br>        <span class="hljs-keyword">return</span> s + (idx &gt; <span class="hljs-number">0</span> ? values[idx-<span class="hljs-number">1</span>] : <span class="hljs-string">&quot;&quot;</span>) + v;<br>    &#125;, <span class="hljs-string">&quot;&quot;</span> );<br>&#125;<br><br><span class="hljs-keyword">var</span> desc = <span class="hljs-string">&quot;awesome&quot;</span>;<br><span class="hljs-keyword">var</span> text = tag<span class="hljs-string">`Everything is <span class="hljs-subst">$&#123;desc&#125;</span>!`</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( text ); <span class="hljs-comment">//  Everything is awesome!</span><br><span class="hljs-comment">//过程解析</span><br><span class="hljs-comment">//strings = [&#x27;Everything is &#x27;, &#x27;!&#x27;, raw]</span><br><span class="hljs-comment">//0: &quot;Everything is &quot;</span><br><span class="hljs-comment">//1: &quot;!&quot;</span><br><span class="hljs-comment">//values = [&#x27;awesome&#x27;]</span><br>| callback    | s             | v             | idx | <span class="hljs-keyword">return</span> value           |<br>| ----------- | ------------- | ------------- | --- | ---------------------- |<br>| first call  | <span class="hljs-string">&quot;&quot;</span>(默认值)    | <span class="hljs-title class_">Everything</span> is | <span class="hljs-number">0</span>   | <span class="hljs-title class_">Everything</span> is          |<br>| second call | <span class="hljs-title class_">Everything</span> is | <span class="hljs-string">&#x27;! &#x27;</span>          | <span class="hljs-number">1</span>   | <span class="hljs-title class_">Everything</span> is awesome! |<br></code></pre></td></tr></table></figure><p>在这个代码段中，<code>tag(..)</code>是一个直通操作，因为它不实施任何特殊的修改，而只是使用<code>reduce(..)</code>来循环遍历，并像一个未打标签的字符串字面量一样，将strings和values拼接/穿插在一起。</p><p>那么实际的用法是什么？有许多高级的用法超出了我们要在这里讨论的范围。但这里有一个格式化美元数字的简单想法（有些像基本的本地化）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">dollabillsyall</span>(<span class="hljs-params">strings, ...values</span>) &#123;<br>    <span class="hljs-keyword">return</span> strings.<span class="hljs-title function_">reduce</span>( <span class="hljs-keyword">function</span>(<span class="hljs-params">s,v,idx</span>)&#123;<br>        <span class="hljs-keyword">if</span> (idx &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> values[idx-<span class="hljs-number">1</span>] == <span class="hljs-string">&quot;number&quot;</span>) &#123;<br>                s += <span class="hljs-string">`$<span class="hljs-subst">$&#123;values[idx-<span class="hljs-number">1</span>].toFixed( <span class="hljs-number">2</span> )&#125;</span>`</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                s += values[idx-<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> s + v;<br>    &#125;, <span class="hljs-string">&quot;&quot;</span> );<br>&#125;<br><br><span class="hljs-keyword">var</span> amt1 = <span class="hljs-number">11.99</span>,<br>    amt2 = amt1 * <span class="hljs-number">1.08</span>,<br>    name = <span class="hljs-string">&quot;Kyle&quot;</span>;<br><br><span class="hljs-keyword">var</span> text = dollabillsyall<br><span class="hljs-string">`Thanks for your purchase, <span class="hljs-subst">$&#123;name&#125;</span>! Your</span><br><span class="hljs-string">product cost was <span class="hljs-subst">$&#123;amt1&#125;</span>, which with tax</span><br><span class="hljs-string">comes out to <span class="hljs-subst">$&#123;amt2&#125;</span>.`</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( text );<br><span class="hljs-comment">// Thanks for your purchase, Kyle! Your</span><br><span class="hljs-comment">// product cost was $11.99, which with tax</span><br><span class="hljs-comment">// comes out to $12.95.</span><br><br><span class="hljs-comment">//过程解析</span><br><span class="hljs-comment">//strings = [&#x27;Thanks for your purchase, &#x27;,</span><br><span class="hljs-comment">// &#x27;! Your\nproduct cost was &#x27;, &#x27;, which with tax\ncomes out to &#x27;, &#x27;.&#x27;, raw]</span><br><span class="hljs-comment">//0: &quot;Thanks for your purchase, &quot;</span><br><span class="hljs-comment">//1: &quot;! Your\nproduct cost was &quot;</span><br><span class="hljs-comment">//2: &quot;, which with tax\ncomes out to &quot;</span><br><span class="hljs-comment">//3: &quot;.&quot;</span><br><span class="hljs-comment">//values = [&#x27;Kyle&#x27;, 11.99, 12.949200000000001]</span><br></code></pre></td></tr></table></figure><p>如果在values数组中遇到一个number值，我们就在它前面放一个&quot;$&quot;并用toFixed(2)将它格式化为小数点后两位有效。否则，我们就不碰这个值而让它直通过去。</p><p><big><strong>raw属性</strong></big><br>这里重点提一下raw属性，它也是一个数组，包含了strings数组中的元素所对应的原始信息，相当于为每个元素调用了一次String对象的raw()方法。注意，String.raw()是一个内置的标签模板，在调用时要用特殊的形式。</p><p>下面用一个例子来演示String.raw()的功能，先定义一个包含水平制表符（\t）的字符串，然后在第一次输出的时候，“<p>”和“&lt;\p&gt;”之间会有空格隔开，接着调用String.raw()，再次输出时就能把“\t”也一并显示。其实要在控制台显示第二条注释需要在“\t”前加一条反斜线（即“\t”）做转义，这样才能把“\t”分成两个独立的字符：“\”和“t”，不再有水平制表符的效果。但此处为了便于理解，省略了反斜线。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> html = <span class="hljs-string">`&lt;p&gt;\t&lt;/p&gt;`</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(html);        <span class="hljs-comment">//&quot;&lt;p&gt;     &lt;/p&gt;&quot;</span><br>html = <span class="hljs-title class_">String</span>.<span class="hljs-property">raw</span><span class="hljs-string">`&lt;p&gt;\t&lt;/p&gt;`</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(html);        <span class="hljs-comment">//&quot;&lt;p&gt;\t&lt;/p&gt;&quot;</span><br></code></pre></td></tr></table></figure><h3 id="3-9-模式匹配">3.9 模式匹配</h3><p>JavaScript定义了一种被称为<code>正则表达式（或RegExp）</code>的数据类型，用于描述和匹配文本中的字符串模式。RegExp不是JavaScript中的基础类型，但具有类似数值和字符串的字面量语法，因此它们有时候看起来像是基础类型。正则表达式字面量的语法很复杂，它们定义的API也没那么简单。由于RegExp很强大，且常用于文本处理，因此这里先简单地介绍一下。</p><p>一对斜杠之间的文本构成正则表达式字面量。这对斜杠中的第二个后面也可以跟一个或多个字母，用于修改模式的含义。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs RegExp">/^HTML/ <br>匹配字符串开头的字母HTML<br><br>/[1-9][0-9]*/<br>匹配非0数字，后面跟着任意数字<br><br>/\bjavascript\b/i<br>匹配&quot;javascript&quot;这个词，不区分大小写<br><br></code></pre></td></tr></table></figure><p>RegExp对象定义了一些有用的方法，而字符串也有接收RegExp参数的方法。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> text = <span class="hljs-string">&#x27;testing:1,2,3&#x27;</span>;<br><span class="hljs-keyword">let</span> patten = <span class="hljs-regexp">/\d+/g</span>;<span class="hljs-comment">//匹配一个或多个数字</span><br>patten.<span class="hljs-title function_">test</span>(text); <span class="hljs-comment">//true,存在匹配项</span><br>text.<span class="hljs-title function_">search</span>(patten);<span class="hljs-comment">//8,第一个匹配的位置</span><br>text.<span class="hljs-title function_">match</span>(patten);<span class="hljs-comment">//[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;]</span><br>text.<span class="hljs-title function_">replace</span>(patten,<span class="hljs-string">&#x27;*&#x27;</span>);<span class="hljs-comment">//&#x27;testing:*,*,*&#x27;</span><br>text.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/\D+/</span>);<span class="hljs-comment">//[&#x27;&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;],基于非数字拆分</span><br></code></pre></td></tr></table></figure><h2 id="4-布尔值-Boolean">4. 布尔值 Boolean</h2><p>布尔值表示真或假、开或关、是或否。这个类型只有两个值：true和false。<br>布尔值在JavaScript中通常是比较操作的结果。例如：<br><code>a===4</code><br>以上代码测试变量a的值是否等于数值4。如果是，则返回true；否则返回false。</p><p>布尔值在JavaScript常用于控制结构。例如，JavaScript中的if/else语句在布尔值为true时会执行一种操作，而在值为false时会执行另一种操作。我们经常把产生布尔值的比较表达式直接放在使用布尔值的语句中。结果类似如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span>(a===<span class="hljs-number">4</span>)&#123;<br>  b=b+<span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>  a=a+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码检查a是否等于4，如果等于，则给b加1；否则，给a加1。</p><p>JavaScript的任何值都可以转换为布尔值。下面的这些值都会转换为（因而可以被用作）布尔值false：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-literal">undefined</span><br><span class="hljs-literal">null</span><br><span class="hljs-number">0</span><br>-<span class="hljs-number">0</span><br><span class="hljs-title class_">NaN</span><br><span class="hljs-string">&#x27;&#x27;</span><span class="hljs-comment">//空字符串</span><br></code></pre></td></tr></table></figure><p>所有其他值，包括所有对象（和数组）都转换为（可以被用作）布尔值true。false和可以转换为它的6个值有时候也被称为假性值（falsy），而所有其他值则被称为真性值（truthy）。在任何JavaScript期待布尔值的时候，假性值都可以当作false，而真性值都可以当作true。</p><p>例如，假设变量o要么保存一个对象，要么是值null。可以通过一个if语句像下面这样检测o是否为非空：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span>(o!==<span class="hljs-literal">null</span>)...<br></code></pre></td></tr></table></figure><p>使用不全等操作符!==比较o和null，求值结果要么是true要么是false。不过，也可以省略比较，直接依赖null是假性值而对象是真性值这个事实：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span>(o)...<br></code></pre></td></tr></table></figure><p>第一种情况下，if语句的主体只有在o不是null时才会被执行。第二种情况没那么严格，只要o不是false或任何其他假性值（如null或undefined），if语句的主体就会执行。哪种if语句适合你的程序取决于你期待o中保存什么值。如果需要区分null和0、“”，那么就应该使用比较表达式。</p><p>布尔值有一个toString()方法，可用于将自己转换为字符串&quot;true&quot;或&quot;false&quot;。除此之外，布尔值再没有其他有用的方法了。除了这个极其简单的API，还有三种重要的布尔值操作符。</p><ul><li><code>&amp;&amp;</code>操作符执行布尔<code>与</code>操作，当且仅当两个操作数都为真时，求值结果才是真；任何一个操作数为假，结果都为假。</li><li><code>||</code>操作符执行布尔<code>或</code>操作，任何一个操作数为真，求值结果就是真；只有当两个操作数均为假时，结果才是假。</li><li>一元的<code>！</code>操作符执行布尔<code>非</code>操作，如果操作数是假则结果为true；如果操作数是真则结果为false。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span>((x===<span class="hljs-number">0</span> &amp;&amp; y===<span class="hljs-number">0</span>) || !(z===<span class="hljs-number">0</span>))&#123;<br>  <span class="hljs-comment">//x与y均为0，或者z不等于0</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-null和undefined">5. null和undefined</h2><h2 id="注释："><em><strong>注释：</strong></em></h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.silentblue.top/2022/06/10/%E6%B5%85%E8%B0%88IEEE754%E6%A0%87%E5%87%86%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AF%AF%E5%B7%AE%E6%88%90%E5%9B%A0/">https://blog.silentblue.top/2022/06/10/浅谈IEEE754标准的浮点数误差成因/</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>Math内置对象 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>IIFE <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/IIFE">https://developer.mozilla.org/zh-CN/docs/Glossary/IIFE</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>toFixed()、.reduce() <a href="http://www.baidu.com">http://www.baidu.com</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
      <category>学习笔记</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据类型</tag>
      
      <tag>数值</tag>
      
      <tag>文本字符串</tag>
      
      <tag>布尔值</tag>
      
      <tag>boolean</tag>
      
      <tag>undefined</tag>
      
      <tag>symbol</tag>
      
      <tag>对象</tag>
      
      <tag>math</tag>
      
      <tag>数学</tag>
      
      <tag>算数</tag>
      
      <tag>object</tag>
      
      <tag>array</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript中相等和严格相等运算符的简要比较</title>
    <link href="/2022/06/12/Javascript%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%B8%A5%E6%A0%BC%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/"/>
    <url>/2022/06/12/Javascript%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%B8%A5%E6%A0%BC%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1-全等运算符">1. 全等运算符 ===</h2><p>首先，全等操作符比较两个值是否相等，两个被比较的值在比较前都不进行隐式转换。如果两个被比较的值具有不同的类型，这两个值是不全等的；其次，如果两个被比较的值类型相同，值也相同，并且都不是 number 类型时，两个值全等；最后，如果两个值都是 number 类型，当两个都不是 NaN，并且数值相同，或是两个值分别为 +0 和 -0 时，两个值被认为是全等的。</p><blockquote><p>注意，在全等运算中，NaN 与其他任何值相比,结果都是 false。</p></blockquote><h3 id="1-1-基本规则">1.1 基本规则</h3><div class="note note-info">            <p><strong>全等和不全等操作符遵循以下基本规则：</strong></p><ol><li>如果两个操作数有不同的类型，它们不是严格相等的；<br><code>1 === &quot;1&quot; // false, undefined === null // false</code></li><li>如果两个操作数都为 null，则它们是严格相等的；<br><code>null === null // true</code></li><li>如果两个操作数都为 undefined，它们是严格相等的；<br><code>undefined === undefined // true</code></li><li>如果一个或两个操作数都是 NaN，它们就不是严格相等的；<br><code>NaN === NaN // false</code></li><li>如果两个操作数都为 true 或都为 false，它们是严格相等的；<br><code>true === true //true, false === false; //true</code></li><li>如果两个操作数都是 number 类型并且具有相同的值，则它们是严格相等的；<br><code>0 === 0 // true</code></li><li>如果两个操作数都是 string 类型并且具有相同的值，则它们是严格相等的；<br><code>&quot;a&quot; === &quot;a&quot; //true</code></li><li>如果两个操作数都引用相同的对象或函数，则它们是严格相等的；<br><code>var firstObject = {},  secondObject = firstObject;</code><br><code>secondObject['name'] = 'Neo';</code><br><code>secondObject === firstObject // true</code></li><li>以上所有其他情况下操作数都不是严格相等的。<br><code>[] === [] //false</code><br><code>[]可以理解为new Array()，相当于声明了一个新的空数组，程序会自动在堆中为其开辟一块内存空间，[]和[]生成的内存空间不是同一块，所以自然不相等。</code></li></ol>          </div><h2 id="2-对象与原始值的转换">2. 对象与原始值的转换</h2><p><a href="/2022/06/16/JavaScript%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%B5%85%E6%9E%90/#3-6-%E8%BD%AC%E6%8D%A2">详细介绍见：JavaScript的数据类型浅析</a></p><p><strong>JavaScript类型转换表:</strong></p><table><thead><tr><th>值</th><th>转换为字符串</th><th>数字</th><th>布尔值</th><th>对象</th></tr></thead><tbody><tr><td>undefined</td><td>“undefined”</td><td>NaN</td><td>false</td><td>throws TypeError</td></tr><tr><td>null</td><td>“null”</td><td>0</td><td>false</td><td>throws TypeError</td></tr><tr><td>true</td><td>“true”</td><td>1</td><td>true</td><td>new Boolean(true)</td></tr><tr><td>false</td><td>“false”</td><td>0</td><td>false</td><td>new Boolean(false)</td></tr><tr><td>“”</td><td>“”</td><td>0</td><td>false</td><td>new String(“”)</td></tr><tr><td>“1.2”</td><td>“1.2”</td><td>1.2</td><td>true</td><td>new String(“1.2”)</td></tr><tr><td>“zero”</td><td>“zero”</td><td>NaN</td><td>true</td><td>new String(“zero”)</td></tr><tr><td>0</td><td>“0”</td><td>0</td><td>false</td><td>new Number(0)</td></tr><tr><td>-0</td><td>“0”</td><td>-0</td><td>false</td><td>new Number(-0)</td></tr><tr><td>NaN</td><td>“NaN”</td><td></td><td>false</td><td>new Number(NaN)</td></tr><tr><td>Infinity</td><td>“Infinity”</td><td></td><td>true</td><td>new Number(Infinity)</td></tr><tr><td>-Infinity</td><td>“-Infinity”</td><td></td><td>true</td><td>new Number(-Infinity)</td></tr><tr><td>1(无穷大,非零)</td><td>“1”</td><td></td><td>true</td><td>new Number(1)</td></tr><tr><td>{}(任意对象)</td><td>对象本身</td><td>对象本身</td><td>true</td><td>new Object({})</td></tr><tr><td><code>[]</code>(数组)</td><td>“”</td><td>0</td><td>true</td><td>new Array()</td></tr><tr><td><code>[0]</code>(数组)</td><td>“0”</td><td>0</td><td>true</td><td>new Array()</td></tr><tr><td><code>[0,1,2]</code>(数组)</td><td>“0,1,2”</td><td>NaN</td><td>true</td><td>new Array()</td></tr><tr><td>function(){}</td><td>函数本身</td><td>NaN</td><td>true</td><td></td></tr></tbody></table><h2 id="3-相等运算符">3. 相等运算符 ==</h2><p>如果两个操作数不是同一类型，那么相等运算符会尝试一些类型转换，然后进行比较。</p><h3 id="3-1-基本规则">3.1 基本规则</h3><div class="note note-info">            <blockquote><p>如果操作数具有相同的类型，请测试它们是否严格相等。 如果它们不严格相等，则它们不相等，否则相等。</p></blockquote><p><strong>如果操作数有不同的类型：</strong></p><ol><li>如果一个操作数为 null 而另一个 undefined，则它们相等;</li><li>如果一个值是数字，另一个是字符串，先将字符串转换为数字，然后使用转换后的值比较;</li><li>如果一个操作数是布尔值，则将 true 转换为 1，将 false 转换为 0，然后使用转换后的值比较;</li><li>如果一个操作数是一个对象，而另一个操作数是一个数字或字符串，则将该对象转换为原始值，再使用转换后的值比较;</li></ol><blockquote><p>在以上的其他情况下，操作数都不相等;</p></blockquote>          </div><h2 id="4-函数和方法">4. 函数和方法</h2><h3 id="4-1-switch…case">4.1 switch…case</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">switch</span> (expression) &#123;<br>   <span class="hljs-keyword">case</span> <span class="hljs-attr">value1</span>:<br>    <span class="hljs-keyword">break</span>;<br>   <span class="hljs-keyword">case</span> <span class="hljs-attr">value2</span>:<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-attr">default</span>:<br>    <span class="hljs-title function_">caseDidNotHappens</span>();<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p><strong>描述：</strong><br>一个 switch 语句首先会计算其 expression 。然后，它将从第一个 case 子句开始直到寻找到一个其表达式值与所输入的 expression 的值所相等的子句（使用 <code>严格运算符 </code>===）并将控制权转给该子句，执行相关语句。（如果多个 case 与提供的值匹配，则选择匹配的第一个 case，即使这些 case 彼此间并不相等。）</p><p>如果没有 case 子句相匹配，程序则会寻找那个可选的 default 子句，如果找到了，将控制权交给它，执行相关语句。若没有 default 子句，程序将继续执行直到 switch 结束。按照惯例，default 子句是最后一个子句，不过也不需要这样做。</p><p>可选的 break 语句确保程序立即从相关的 case 子句中跳出 switch 并接着执行 switch 之后的语句。若 break 被省略，程序会继续执行 switch 语句中的下一条语句。</p>          </div><h3 id="4-2-indexOf">4.2 indexOf()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">arr.<span class="hljs-title function_">indexOf</span>(searchElement[, fromIndex])<br></code></pre></td></tr></table></figure><blockquote><p>该方法将从头到尾地检索字符串 arr，看它是否含有子串 searchElement。开始检索的位置在字符串的 fromIndex 处或字符串的开头（没有指定 fromIndex 时）。如果找到一个 searchElement，则返回 searchElement 的第一次出现的位置。arr 中的字符位置是从 0 开始的。</p></blockquote><div class="note note-info">            <p><strong>提示和注释：</strong></p><p><em><strong>注释：</strong></em><br>indexOf() 方法对大小写敏感。</p><p>fromIndex 开始查找的位置。<br>如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回 -1。<br>如果参数中提供的索引值是一个负值，则将其作为数组末尾的一个抵消，即 -1 表示从最后一个元素开始查找，-2 表示从倒数第二个元素开始查找 ，以此类推。</p><p><em><strong>描述：</strong></em><br>indexOf 使用<code>严格相等运算符</code> 进行判断 searchElement 与数组中包含的元素之间的关系。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
      <category>学习笔记</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>===</tag>
      
      <tag>严格相等运算符</tag>
      
      <tag>==</tag>
      
      <tag>相等运算符</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈IEEE 754标准的浮点数误差成因</title>
    <link href="/2022/06/10/%E6%B5%85%E8%B0%88IEEE754%E6%A0%87%E5%87%86%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AF%AF%E5%B7%AE%E6%88%90%E5%9B%A0/"/>
    <url>/2022/06/10/%E6%B5%85%E8%B0%88IEEE754%E6%A0%87%E5%87%86%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AF%AF%E5%B7%AE%E6%88%90%E5%9B%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-IEEE-754标准的产生">1. IEEE 754标准的产生</h2><p>20 世纪 80 年代（没有制定 IEEE 754 标准）之前，业界还没有一个统一的浮点数标准。相反，很多计算机制造商根据自己的需要来设计自己的浮点数表示规则，以及浮点数的执行运算细节。另外，他们常常并不太关注运算的精确性，而把实现的速度和简易性看得比数字的精确性更重要，而这就给代码的可移植性造成了重大的障碍。</p><p>直到 1976 年，Intel 公司打算为其 8086 微处理器引进一种浮点数协处理器时，意识到作为芯片设计者的电子工程师和固体物理学家也许并不能通过数值分析来选择最合理的浮点数二进制格式。于是，他们邀请加州大学伯克利分校的 William Kahan 教授（当时最优秀的数值分析家）来为 8087 浮点处理器（FPU）设计浮点数格式。而这时，William Kahan 教授又找来两个专家协助他，于是就有了 KCS 组合（Kahn、Coonan和Stone），并共同完成了 Intel 公司的浮点数格式设计。</p><p>由于 Intel 公司的 KCS 浮点数格式完成得如此出色，以致 IEEE（Institute of Electrical and Electronics Engineers，电子电气工程师协会）决定采用一个非常接近 KCS 的方案作为 IEEE 的标准浮点格式。于是，IEEE 于 1985 年制订了二进制浮点运算标准 IEEE 754（IEEE Standard for Binary Floating-Point Arithmetic，ANSI/IEEE Std 754-1985），该标准限定指数的底为 2，并于同年被美国引用为 ANSI 标准。目前，几乎所有的计算机都支持 IEEE 754 标准，它大大地改善了科学应用程序的可移植性。</p><p>考虑到 IBM System/370 的影响，IEEE 于 1987 年推出了与底数无关的二进制浮点运算标准 IEEE 854，并于同年被美国引用为 ANSI 标准。1989 年，国际标准组织 IEC 批准 IEEE 754/854 为国际标准 IEC 559：1989。后来经修订后，标准号改为 IEC 60559。现在，几乎所有的浮点处理器完全或基本支持 IEC 60559。同时，C99 的浮点运算也支持 IEC 60559。</p><h2 id="2-标准浮点格式">2. 标准浮点格式</h2><p>IEEE 754标准准确地定义了单精度和双精度浮点格式，并为这两种基本格式分别定义了扩展格式，如下所示：</p><blockquote><ul><li>单精度浮点格式（32 位）。</li><li>双精度浮点格式（64 位）。</li><li>扩展单精度浮点格式（≥43 位，不常用）。</li><li>扩展双精度浮点格式（≥79 位，一般情况下，Intel x86 结构的计算机采用的是 80 位，而 SPARC 结构的计算机采用的是 128 位）。</li></ul></blockquote><p>其中，只有 32 位单精度浮点数是本标准强烈要求支持的，其他都是可选部分。本文主要针对单精度浮点与双精度浮点的存储格式做一些简要的阐述。</p><h3 id="2-1-什么是浮点误差">2.1 什么是浮点误差</h3><p>很多人在写代码时中都曾经遇到过所谓的浮点误差，以js为例来看0.1+0.2结果是什么：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;浮点误差：&quot;</span> + <span class="hljs-string">&quot;\n&quot;</span> + <span class="hljs-string">&quot;0.1+0.2=&quot;</span> + <span class="hljs-string">&quot;\n&quot;</span> + (<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>));<br><span class="hljs-comment">//浮点误差：</span><br><span class="hljs-comment">//0.1+0.2=</span><br><span class="hljs-comment">//0.30000000000000004</span><br></code></pre></td></tr></table></figure><p>正常情况下应该是0.1+0.2=0.3，但为什么运算结果却不是呢，这并不是什么bug，也并不是程序设计有问题，这个原因与浮点数的存储原理有关。在开始了解浮点数的存储原理前，需要先知道js中数值是以何种形式存储的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs info">JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。<br>所以，1与1.0是相同的，是同一个数。<br><br>1 === 1.0 // true<br><br>这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。<br>容易造成混淆的是，某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，<br>然后再进行运算。<br><br>由于浮点数不是精确的值，所以js中涉及小数的比较和运算要特别小心。<br></code></pre></td></tr></table></figure><h3 id="2-2-计算机中是如何存储整数的">2.2 计算机中是如何存储整数的</h3><p>在了解为什么会产生浮点误差前，我们先了解一下计算机是如何用0和1来表示一个整数的。我们知道计算机主要是采用二进制计算和存储数据的，我们假设一个<code>32bit</code>的无符号整数（unsigned integer），那么就是说它有32个位置来存放0或1，那么它的值的范围就是0~2<sup>32</sup>-1，即0~4294967295，也就是说它可以精确的表达出0~4294967295之间任意整数而不会有误差。</p><p>同时，我们可以看得出虽然0~2<sup>32</sup>有很多整数，但个数毕竟是有限的，但是浮点数就不同了，它可以有例如，2.1，2.11，2.111…等等无数个浮点数。那么该如何把这些无限的浮点数塞进有限的<code>32bit</code>的空间里呢，在IEEE 754标准诞生前，各个CPU厂家发明了各种浮点数的表示方法，后来则是统一遵循这个标准进行设计。</p><h3 id="2-3-浮点数格式的正规化">2.3 浮点数格式的正规化</h3><p>浮点数在存储之前必需先进行符合IEEE 754的格式的正规化操作，即由一个有效数字乘以2的整数次幂得到,类似于十进制的科学计数法，下面举例说明：</p><blockquote><p>浮点数5.5如何进行格式正规化：<br>5.5=5+0.5<br>转化为二进制：<br>2<sup>2</sup>+2<sup>1</sup>+2<sup>-1</sup> 即 101.1<br>格式正规化：<br>1.011×2<sup>2</sup></p></blockquote><h3 id="2-4-十进制与二进制的转化">2.4 十进制与二进制的转化</h3><p>十进制数值转化为二进制方法之一：整数部分为留余数，倒排序；小数部分为乘以2，一直到全部转化整数为止，正排序。也可使用<a href="https://tool.oschina.net/hexconvert">在线进制转换工具</a></p><blockquote><p>十进制8.125转化为二进制：<br>整数部分：<br>8÷2=4 余数 <code>0</code>；4÷2=2 余数 <code>0</code>；2÷2=1 余数 <code>0</code>；最后剩余 <code>1</code>；倒排序二进制表示为 <code>1000</code><br>小数部分：<br>0.125×2=0.25 整数部分 <code>0</code>；0.25×2=0.5 整数部分 <code>0</code>；0.5×2=1 整数部分 <code>1</code>；正序二进制表示为 <code>001</code><br>因此十进制<code>8.125</code>转化为二进制为 <code>1000.001</code></p></blockquote><h3 id="2-5-浮点数的表示法">2.5 浮点数的表示法</h3><p>一个浮点数分为三个部分，分别是符号位（sign bit），指数偏移值(exponent bias)，分数值(fraction)。浮点数的值(value)=符号位（sign bit）×指数偏移值(exponent bias)×有效数(fraction)。</p><blockquote><p>符号(S) :用來表示正/负(0/1)。<br>指数(E) :浮点数正规化后的次方，单精度的指数部分采用超127格式，即将原本的次方数加上127，因为次方数有可能是负的，加上计算机要表示负号时，必须拿一个位元来表示，所以就将-128~+127改为0~255，所以基准点就从0变成127。双精度的指数部分是−1022～+1023加上1023，指数值的大小从1～2046（0（2进位全为0）和2047（2进位全为1）是特殊值）。浮点小数计算时，指数值减去偏正值将是实际的指数大小。<br>有效数(F) :正规化后小数点之后的值。</p></blockquote><h4 id="单精度浮点数-float">单精度浮点数(float)</h4><p><img src="1-1.jpg" alt="单精度浮点数表示法"><br>sign：最左侧<code>1bit</code> 代表正负号，正数的话<code>sign</code>就为<code>0</code>，反之则是 <code>1</code><br>exponent：中间的<code>8bit</code>代表正规化后的次方数，采用的是<code>超127格式</code>，也就是<code>次方数</code>还要再加上<code>127</code><br>fraction：最右侧的<code>23bit</code> 放的是小数部分，以<code>1.0001</code>来说就是去掉<code>1.</code>之后的<code>0001</code></p><p>我们以<code>8.125</code>为例，表示成IEEE 754标准的<code>32bit</code>格式：</p><blockquote><p>正规化：8.125=+1.000001×2<sup>3</sup></p></blockquote><table><thead><tr><th>Sign</th><th>Exponent</th><th>Fraction</th></tr></thead><tbody><tr><td>0 (+)</td><td>1000 0010 (3+127=130)</td><td>0000 0100 0000 0000 0000 000</td></tr></tbody></table><blockquote><p>二进制表示：0100 0001 0000 0010 0000 00000 0000 0000</p></blockquote><p>0.1 + 0.2 != 0.3的原因就在于0.1、0.2和0.3分别用二进制表示时，均无法转化成2的次方数相加，最后产生不同误差。</p><p>有兴趣可以到<a href="https://www.h-schmidt.net/FloatConverter/IEEE754.html">IEEE-754 Floating Point Converter</a>官网测试。</p><h4 id="双精度浮点数-double">双精度浮点数(double)</h4><p>为了让误差更小，<code>IEEE 754</code>也定义了如何用<code>64bit</code>来表示浮点数，跟<code>32bit</code>比起来<code>fraction</code>部分大了超过两倍，从<code>23bit</code>变成<code>52bit</code>，所以精准度自然提高许多。</p><p><img src="1-2.jpg" alt="双精度浮点数表示法"><br>sign：最左侧<code>1bit</code> 代表正负号，正数的话<code>sign</code>就为<code>0</code>，反之则是 <code>1</code><br>exponent：中间的<code>1bit</code>代表正规化后的次方数，采用的是<code>超1023格式</code>，也就是<code>次方数</code>还要再加上<code>1023</code><br>fraction：最右侧的<code>52bit</code> 放的是小数部分，以<code>1.0001</code>来说就是去掉<code>1.</code>之后的<code>0001</code></p><p><img src="2.jpg" alt="单双精度浮点数的对比"></p><h3 id="2-6-如何解决浮点数误差">2.6 如何解决浮点数误差</h3><p>1、设定一个最大允许误差值（EPSILON）<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON">例如ES6中内置的Number.EPSILON</a></p><blockquote><p>例如把 0.1 + 0.2 == 0.3改写成 0.1 + 0.2 — 0.3 &lt;= epsilon</p></blockquote><p>2、完全使用十进制进行计算，但不建议大规模使用，因为十进制计算是组件模拟出来的，CPU计算时仍会转化为二进制，会拖慢运算速度。</p><!-- $$E=mc^2$$ --><!-- ```mermaid --><!-- classDiagramClass01 <|-- AveryLongClass : CoolClass03 *-- Class04Class05 o-- Class06Class07 .. Class08Class09 --|> C2 : Where am i?Class09 --* C3Class09 --|> Class07Class07 : equals()Class07 : Object[] elementDataClass01 : size()Class01 : int chimpClass01 : int gorillaClass08 <--|> C2: Cool label --><!-- ``` --><!-- <a class="btn" href="url" title="title">text</a> -->]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
      <category>学习笔记</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IEEE754</tag>
      
      <tag>浮点数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IEEE754</title>
    <link href="/2022/06/10/IEEE754/"/>
    <url>/2022/06/10/IEEE754/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>条件语句和循环语句</title>
    <link href="/2022/06/07/%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"/>
    <url>/2022/06/07/%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="1-条件语句">1. 条件语句</h2><p>JavaScript提供 <a href="">if</a> 结构和 <a href="">switch</a> 结构，用以完成条件判断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs parsing">即只有满足预设的条件，才会执行相应的语句。<br></code></pre></td></tr></table></figure><h3 id="1-1-if-结构">1.1 <a href="">if</a> 结构</h3><p>if 结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句。所谓布尔值，指的是 JavaScript 的两个特殊值，true表示“真”，false表示“伪”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (布尔值)<br>  语句;<br><br><span class="hljs-comment">// 或者</span><br><span class="hljs-keyword">if</span> (布尔值) 语句;<br></code></pre></td></tr></table></figure><p>上面这种写法要求条件表达式后面只能有一个语句。如果想执行多个语句，必须在if的条件判断之后，加上大括号，表示代码块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (布尔值) &#123;<br>  语句一;<br>  语句二;<br>  ...<br>  语句N;<br>&#125;<br></code></pre></td></tr></table></figure><p>建议总是在if语句中使用大括号，因为这样方便插入语句。</p><h3 id="1-2-if…else-结构">1.2 <a href="">if…else</a> 结构</h3><p>if代码块后面，还可以跟一个else代码块，表示不满足条件时，所要执行的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (布尔值) &#123;<br>  <span class="hljs-comment">// 满足条件时，执行的语句</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 不满足条件时，执行的语句</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对同一个变量进行多次判断时，多个if…else语句可以连写在一起。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (条件一) &#123;<br>  <span class="hljs-comment">// 满足条件一执行</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (条件二) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (条件三) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>else代码块总是与离自己最近的那个if语句配对。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> m = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> n = <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">if</span> (m !== <span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> (n === <span class="hljs-number">2</span>) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;world&#x27;</span>);<br></code></pre></td></tr></table></figure><p>上面代码不会有任何输出，else代码块不会得到执行，因为它跟着的是最近的那个if语句，相当于下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (m !== <span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;world&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果想让else代码块跟随最上面的那个if语句，就要改变大括号的位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (m !== <span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>  &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;world&#x27;</span>);<br>&#125;<br><span class="hljs-comment">// world</span><br></code></pre></td></tr></table></figure><h3 id="1-3-switch-结构">1.3 <a href="">switch</a> 结构</h3><p>多个<a href="">if…else</a>连在一起使用的时候，可以转为使用更方便的<a href="">switch</a>结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">switch</span> (x) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;x 等于1&#x27;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;x 等于2&#x27;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-attr">default</span>:<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;x 等于其他值&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码根据变量x的值，选择执行相应的case。如果所有case都不符合，则执行最后的default部分。需要注意的是，每个case代码块内部的break语句不能少，否则会接下去执行下一个case代码块，而不是跳出switch结构。</p><p>switch语句部分和case语句部分，都可以使用表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">switch</span> (<span class="hljs-number">1</span> + <span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span> + <span class="hljs-number">2</span>:<br>    <span class="hljs-title function_">fn</span>();<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-attr">default</span>:<br>    <span class="hljs-title function_">neverHappens</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>switch表达式与case表示式比较运行结果时，采用的是 <strong>严格相等运算符（===）</strong>，而不是 <strong>相等运算符（==）</strong>，这意味着比较时 <em>不会发生</em> 类型转换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">switch</span> (x) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-attr">true</span>:<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;x 发生类型转换&#x27;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-attr">default</span>:<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;x 没有发生类型转换&#x27;</span>);<br>&#125;<br><span class="hljs-comment">// x 没有发生类型转换</span><br></code></pre></td></tr></table></figure><p>上面代码中，由于变量x <strong>没有发生类型转换</strong>，所以不会执行case true的情况。这表明，switch语句内部采用的是 <strong>严格相等运算符</strong>。</p><h3 id="1-4-三元运算符-结构">1.4 三元运算符<a href="">? :</a> 结构</h3><p>JavaScript 还有一个三元运算符（即该运算符需要三个运算子）<a href="">? :</a>，也可以用于逻辑判断。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(条件) ? 表达式<span class="hljs-number">1</span> : 表达式<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>上面代码中，如果“条件”为true，则返回“表达式1”的值，否则返回“表达式2”的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> even = (n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><p>上面代码中，如果n可以被2整除，则even等于true，否则等于false。它等同于下面的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> even;<br><span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) &#123;<br>  even = <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  even = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个三元运算符可以被视为 <a href="">if…else…</a> 的简写形式，因此可以用于多种场合。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myVar;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>  myVar ?<br>  <span class="hljs-string">&#x27;myVar has a value&#x27;</span> :<br>  <span class="hljs-string">&#x27;myVar does not have a value&#x27;</span><br>)<br><span class="hljs-comment">// myVar does not have a value</span><br><br><span class="hljs-keyword">var</span> msg = <span class="hljs-string">&#x27;数字&#x27;</span> + n + <span class="hljs-string">&#x27;是&#x27;</span> + (n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> ? <span class="hljs-string">&#x27;偶数&#x27;</span> : <span class="hljs-string">&#x27;奇数&#x27;</span>);<br><br></code></pre></td></tr></table></figure><p>上面代码利用三元运算符，输出相应的提示和在字符串之中插入不同的值。</p><h2 id="2-循环语句">2. 循环语句</h2><p>循环语句用于重复执行某个操作，它有多种形式。</p><h3 id="2-1-while-循环">2.1 <a href="">while</a> 循环</h3><p><a href="">while</a> 语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">while</span> (条件)<br>  语句;<br><span class="hljs-comment">// 或者</span><br><span class="hljs-keyword">while</span> (条件) 语句;<br><br><span class="hljs-comment">//多条语句</span><br><span class="hljs-keyword">while</span> (条件) &#123;<br>  语句一;<br>  ...<br>  语句N;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>while语句的循环条件是一个表达式，必须放在圆括号中。代码块部分，如果只有一条语句，可以省略大括号，否则就必须加上大括号。</p><h3 id="2-2-for-循环">2.2 <a href="">for</a> 循环</h3><p><a href="">for</a> 语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。它的格式如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (初始化表达式; 条件; 递增表达式)<br>  语句<br><br><span class="hljs-comment">// 或者</span><br><br><span class="hljs-keyword">for</span> (初始化表达式; 条件; 递增表达式) &#123;<br>  语句<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="">for</a> 语句后面的括号里面，有三个表达式。</p><blockquote><p>~</p><ul><li>初始化表达式（initialize）：确定循环变量的初始值，只在循环开始时执行一次。</li><li>条件表达式（test）：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。</li><li>递增表达式（increment）：每轮循环的最后一个操作，通常用来递增循环变量。</li></ul><p>~</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; x; i++) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>&#125;<br><span class="hljs-comment">// 0</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>上面代码中，初始化表达式是var i = 0，即初始化一个变量i；测试表达式是i &lt; x，即只要i小于x，就会执行循环；递增表达式是i++，即每次循环结束后，i增大1。</p><p>所有for循环，都可以改写成while循环。上面的例子改为while循环，代码如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span> (i &lt; x) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  i++;<br>&#125;<br></code></pre></td></tr></table></figure><p>for语句的三个部分（initialize、test、increment），可以省略任何一个，也可以全部省略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> ( ; ; )&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello World&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码省略了for语句表达式的三个部分，结果就导致了一个无限循环。</p><h3 id="2-3-do…while-循环">2.3 <a href="">do…while</a> 循环</h3><p><a href="">do…while</a> 循环与 <a href="">while</a> 循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">do</span><br>  语句<br><span class="hljs-keyword">while</span> (条件);<br><br><span class="hljs-comment">// 或者</span><br><span class="hljs-keyword">do</span> &#123;<br>  语句<br>&#125; <span class="hljs-keyword">while</span> (条件);<br><br><span class="hljs-comment">//eg:</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">do</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  i++;<br>&#125; <span class="hljs-keyword">while</span>(i &lt; x);<br><span class="hljs-comment">//0</span><br><span class="hljs-comment">//1</span><br><span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure><p>不管条件是否为真，<a href="">do…while</a> 循环至少运行一次，这是这种结构最大的特点。另外，while语句后面的分号注意不要省略。</p><h3 id="2-4-break-语句和-continue-语句">2.4 <a href="">break</a> 语句和 <a href="">continue</a> 语句</h3><p><a href="">break</a> 语句和<a href="">continue</a> 语句都具有跳转作用，可以让代码不按既有的顺序执行。</p><p><a href="">break</a> 语句用于跳出代码块或循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span>(i &lt; <span class="hljs-number">100</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;i 当前为：&#x27;</span> + i);<br>  i++;<br>  <span class="hljs-keyword">if</span> (i === <span class="hljs-number">10</span>) <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码只会执行10次循环，一旦i等于10，就会跳出循环。</p><p>for循环也可以使用break语句跳出循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  <span class="hljs-keyword">if</span> (i === <span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">// 0</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>上面代码执行到i等于3，就会跳出循环。</p><p><a href="">continue</a> 语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">100</span>)&#123;<br>  i++;<br>  <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;i 当前为：&#x27;</span> + i);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码只有在i为奇数时，才会输出i的值。如果i为偶数，则直接进入下一轮循环。</p><p>如果存在多重循环，不带参数的 <a href="">break</a> 语句和 <a href="">continue</a> 语句都只针对最内层循环。</p><h3 id="2-5-标签（label-）">2.5 标签（<a href="">label</a> ）</h3><p>JavaScript 语言允许，语句的前面有标签（<a href="">label</a> ），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">label</span>:<br>  语句<br></code></pre></td></tr></table></figure><p>标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。</p><p>标签通常与 <a href="">break</a> 语句和 <a href="">continue</a> 语句配合使用，跳出特定的循环。</p><p>[eg:]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">top</span>:<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)&#123;<br>      <span class="hljs-keyword">if</span> (i === <span class="hljs-number">1</span> &amp;&amp; j === <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span> top;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;i=&#x27;</span> + i + <span class="hljs-string">&#x27;, j=&#x27;</span> + j);<br>    &#125;<br>  &#125;<br><span class="hljs-comment">// i=0, j=0</span><br><span class="hljs-comment">// i=0, j=1</span><br><span class="hljs-comment">// i=0, j=2</span><br><span class="hljs-comment">// i=1, j=0</span><br></code></pre></td></tr></table></figure><p>上面代码为一个双重循环区块，<a href="">break</a> 命令后面加上了 <a href="">top</a> 标签（注意，top不用加引号），满足条件时，直接跳出双层循环。如果break语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。</p><blockquote><p>标签也可以用于跳出代码块。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">foo</span>: &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">break</span> foo;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;本行不会输出&#x27;</span>);<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><blockquote><p>上面代码执行到break foo，就会跳出区块。</p></blockquote><p>continue语句也可以与标签配合使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">top</span>:<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)&#123;<br>      <span class="hljs-keyword">if</span> (i === <span class="hljs-number">1</span> &amp;&amp; j === <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span> top;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;i=&#x27;</span> + i + <span class="hljs-string">&#x27;, j=&#x27;</span> + j);<br>    &#125;<br>  &#125;<br><span class="hljs-comment">// i=0, j=0</span><br><span class="hljs-comment">// i=0, j=1</span><br><span class="hljs-comment">// i=0, j=2</span><br><span class="hljs-comment">// i=1, j=0</span><br><span class="hljs-comment">// i=2, j=0</span><br><span class="hljs-comment">// i=2, j=1</span><br><span class="hljs-comment">// i=2, j=2</span><br></code></pre></td></tr></table></figure><p>上面代码中，<a href="">continue</a> 命令后面有一个标签名，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果continue语句后面不使用标签，则只能进入下一轮的内层循环</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
      <category>学习笔记</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>条件语句</tag>
      
      <tag>循环语句</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/06/07/hello-world/"/>
    <url>/2022/06/07/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
